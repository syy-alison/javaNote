[TOC]



### [**:house:**](../../README.html)

满二叉树的节点数：2^深度 - 1

## 普通二叉树

#### [1. 二叉树的前序，中序，后序遍历](https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=196&tqId=37153&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)

分别按照二叉树先序，中序和后序打印所有的节点。

递归法  https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/

```java
//时间复杂度:O(N)
//空间复杂度;O(N)

public List<Integer> prelist;
    public List<Integer> midlist;
    public List<Integer> postlist;
    public int[][] threeOrders (TreeNode root) {
        // write code here
        prelist=new ArrayList<>();
        midlist=new ArrayList<>();
        postlist=new ArrayList<>();
         
        perorder(root);
        midorder(root);
        postorder(root);
        int [][]res=new int[3][prelist.size()];
       
         for(int i=0;i<prelist.size();i++){
             res[0][i]=prelist.get(i);
         }
         for(int i=0;i<prelist.size();i++){
             res[1][i]=midlist.get(i);
         }
         for(int i=0;i<prelist.size();i++){
             res[2][i]=postlist.get(i);
         }
        
        return res;
    }
    //前序遍历
    public void perorder(TreeNode root){
        
        if(root==null) return;
        
        prelist.add(root.val);
        perorder(root.left);
        perorder(root.right);
       
    }
    //中序遍历
    public void midorder(TreeNode root){
        
        if(root==null)  return;
        midorder(root.left);
        midlist.add(root.val);
        midorder(root.right);
         
        
    }
    //后序遍历
    public void postorder(TreeNode root){
        
        if(root==null) return;
        postorder(root.left);
        postorder(root.right);
        postlist.add(root.val);
          
    }
  
```

非递归法

```java
//前序遍历
//时间复杂度O(N)
//空间复杂度O(N)
public List<Integer> preorderTraversal(TreeNode root) {


        List<Integer> res = new ArrayList<Integer>();
        Deque<TreeNode> st = new LinkedList<TreeNode>();
        st.push(root);
        while(!st.isEmpty()){

            TreeNode node = st.pop();
            if(node == null)  continue;//先判断一下是不是空，因此我们每次加进去的有可能是空节点
            res.add(node.val);
            st.push(node.right);//由于是栈，所以先把右节点放进去
            st.push(node.left);
        }

        return res;
        
    }

//后序遍历
//时间复杂度O(N)
//空间复杂度O(N)
public List<Integer> preorderTraversal(TreeNode root) {


        List<Integer> res = new ArrayList<Integer>();
        Deque<TreeNode> st = new LinkedList<TreeNode>();
        st.push(root);
        while(!st.isEmpty()){

            TreeNode node = st.pop();
            if(node == null)  continue;//先判断一下是不是空，因此我们每次加进去的有可能是空节点
            res.add(node.val);
            st.push(node.left);//由于是栈，所以先把左节点放进去
            st.push(node.right);
        }
        Collections.reverse(res);  //根右左---->左右根
        return  res;
        
    }


//中序遍历
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    if (root == null) return ret;
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {//把左节点加入栈中
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();//每弹出一个节点
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}
```

#### [2. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/)

给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）

```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> path = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                path.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(path);
        }
        return result;


    }
}
```

#### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**示例 1：**

![tree1.jpg](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                temp.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }  
                if(node.right != null){
                   queue.offer(node.right);
                }                               
             }
             result.add(temp);
        }
        Collections.reverse(result);
        return result;

    }
}
```



#### [3.二叉树的之字型层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）

```java
//时间复杂度O(N) 空间复杂度O(N)
public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){

            int size = q.size();
            LinkedList<Integer> temp  = new LinkedList<>();
            for(int i = 0; i < size; i++){
                TreeNode node = q.remove();
                if(res.size() % 2 == 1) temp.addFirst(node.val);
                else temp.addLast(node.val);
                if(node.left!=null) q.add(node.left);
                if(node.right != null) q.add(node.right);
            }
            res.add(temp);
        }

        return res;

    }

//时间复杂度O(N) 空间复杂度O(N)
public ArrayList<ArrayList<Integer>> zigzagLevelOrder (TreeNode root) {
        // write code here
        
        ArrayList<ArrayList<Integer>> res=new ArrayList<ArrayList<Integer>>();
        if(root==null) return res;
        Stack <TreeNode> st1 =new Stack<TreeNode>();//奇数层用一个栈
        Stack <TreeNode> st2 =new Stack<TreeNode>();//偶数层再用一个栈
        
        st1.push(root);
       
        
        while(!st1.isEmpty() || !st2.isEmpty()){
            
            if(!st1.isEmpty()){
                int st1Size=st1.size();

                ArrayList<Integer> temp=new ArrayList<Integer>();

                for(int i=0;i<st1Size;i++){

                    TreeNode node=st1.pop();
                    temp.add(node.val);
                    if(node.left!=null) st2.push(node.left);//
                    if(node.right!=null)st2.push(node.right);

                }
      
                 res.add(temp);
            }
        
         if(!st2.isEmpty()){
            int st2Size=st2.size();
            ArrayList<Integer> temp=new ArrayList<Integer>();
            for(int i=0;i<st2Size;i++){
                
                TreeNode node=st2.pop();
                temp.add(node.val);
                if(node.right!=null) st1.push(node.right);//倒一下
                if(node.left!=null)st1.push(node.left);
                
            }
           res.add(temp);
            
        }
      }
        
        return res;
    }
```

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

```Java
/*递归解析：
终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；
递推工作：
初始化节点 tmp ，用于暂存 root 的左子节点；
开启递归 右子节点 mirrorTree(root.right)，并将返回值作为 root的左子节点 。
开启递归 左子节点 mirrorTree(tmp)，并将返回值作为 root 的右子节点 。
返回值： 返回当前节点 root ；
时间复杂度O(N)
空间复杂度O(N)
*/

public TreeNode mirrorTree(TreeNode root) {


        if(root == null) return null;

        TreeNode temp = root.right;
        root.right = mirrorTree(root.left);//root的右子树等于左子树的镜像
        root.left = mirrorTree(temp);//root的左子树等于右子树的镜像

        return root;
    }
```

#### [4.二叉树的两个节点最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/)

给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。

```java
//时间复杂度O(N) 
//空间复杂度O(N) 最坏的情况下为一条链，此时高度为O(N)
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        if(root == null || root.val == p.val || root.val ==q.val)  return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);//在左子树上找p和q
        TreeNode right = lowestCommonAncestor(root.right,p,q);//在右子树上找p和q

        if(left == null) return right;//如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，右子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先）
        if(right == null) return left;// 否则，如果 left不为空，在左子树中有找到节点（p或q），这时候要再判断一下右子树中的情况，如果在右子树中，p和q都找不到，则 p和q一定都在左子树中，左子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先）
        return root;//否则，当 left和 right均不为空时，说明 p、q节点分别在 root异侧, 最近公共祖先即为 root
        
    }
```

#### [5.重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
//
 	int []preorder;
    Map<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {

        this.preorder = preorder;
        for(int i = 0; i < inorder.length;i++){

            map.put(inorder[i],i);
        }

        return dfs(0,0, inorder.length - 1);
    }

 /**
     * @param root  先序遍历的索引
     * @param left 中序遍历的索引
     * @paramright中序遍历的索引
     */

    public TreeNode dfs(int root, int left, int right){

        if(left > right) return null;
        TreeNode node = new TreeNode(preorder[root]);
        int i = map.get(preorder[root]);
        node.left = dfs(root+1,left,i-1);//左子树：根节点（root+1）,中序遍历左边界（left）,中序遍历右边界（i-1）
        node.right = dfs(i-left+root+1,i+1,right);//右子树：根节点（i - left + root + 1）,中序遍历左边界（i + 1）,中序遍历右边界（right）i - left + root + 1 含义为 根节点索引 + 左子树长度 + 1
        return node;

    }

//时间复杂度O(N)
//空间复杂度O(N)

public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        
        if(pre.length==0) return null;
        
        TreeNode root=new TreeNode(pre[0]);//获取根节点
        
        for(int i=0;i<in.length;i++){//遍历中序获取根节点的位置。
            
            if(in[i]==pre[0]){//构造左右子树
                
            root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i));
            root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,in.length),Arrays.copyOfRange(in,i+1,in.length));
                
                break;
            }
        }
        
        return root;
            
        
    }

//不使用Arrays.copyOfRange
  public TreeNode buildTree(int[] preorder, int[] inorder) {

       TreeNode node = dfs(preorder,inorder,0,preorder.length-1,0,inorder.length-1);
       return node;

    }

    public TreeNode dfs(int[] preorder, int[] inorder, int preleft, int preright, int inleft,int inright){

        if(preleft > preright)  return null;
        TreeNode node = new TreeNode(preorder[preleft]);
        if(preleft == preright)  return node;
        for(int i = inleft; i <= inright;i++){

            if(inorder[i] == node.val){

                node.left = dfs(preorder,inorder,preleft + 1,preleft - inleft + i,inleft,i-1);
                node.right = dfs(preorder,inorder,preleft - inleft + i + 1,preright,i+1,inright);
                break;
            }
        }

        return node;


    }

```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    Map<Integer, Integer> map;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return buildTree(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);

    }

    public TreeNode buildTree(int[] inorder, int[] postorder, int inorderBegin, int inorderEnd, int postorderBegin,
            int postorderEnd) {
        if (inorderBegin > inorderEnd || postorderBegin > postorderEnd) {
            return null;
        }
        int rootVal = postorder[postorderEnd];
        int inorderRootIdx = map.get(rootVal);
        TreeNode root = new TreeNode(rootVal);
        int inorderSize = inorderRootIdx - inorderBegin;
        root.left = buildTree(inorder, postorder, inorderBegin, inorderRootIdx - 1, postorderBegin,
                postorderBegin + inorderSize - 1);
        root.right = buildTree(inorder, postorder, inorderRootIdx + 1, inorderEnd, postorderBegin + inorderSize,
                postorderEnd - 1);
        return root;

    }

}

```

#### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树\*** 。

**示例 1：**

![tree1.jpg](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return dfs(nums,0,nums.length - 1);

    }

    public TreeNode dfs(int[] nums, int leftIdx, int rightIdx) {
        if(leftIdx > rightIdx){
            return null;
        }
        if(leftIdx == rightIdx){
            return new TreeNode(nums[leftIdx]);
        }

        int maxIdx = leftIdx;
        int maxVal = nums[leftIdx];
        for(int i = leftIdx + 1; i <= rightIdx; i++){
            if(nums[i] > maxVal){
                maxIdx = i;
                maxVal = nums[i];
            }
        }
        TreeNode node = new TreeNode(maxVal);
        node.left = dfs(nums,leftIdx,maxIdx - 1);
        node.right = dfs(nums,maxIdx + 1,rightIdx);
        return node;

    }
}
```

#### [6.输入二叉树的右视图](https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=196&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图

```java
//先构造二叉树 时间复杂度O(N) 空间复杂度O(N)
//再层序遍历 时间复杂度O(N)  空间复杂度O(N)
public int[] solve (int[] xianxu, int[] zhongxu) {
        // write code here
        
        TreeNode root=getTree(xianxu,zhongxu);
        
        ArrayList<Integer> list=new ArrayList<Integer>();
        Queue <TreeNode>q= new LinkedList<TreeNode>();
        
         q.add(root);
        while(!q.isEmpty()){
            
            int size=q.size();
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                if(i==size-1) list.add(node.val);
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
                
            }
        }
        
        int []res=new int[list.size()];
        for(int i=0;i<list.size();i++){
            res[i]=list.get(i);
            
        }
        
        return res;        
        
        
    }
    
    public TreeNode getTree(int [] pre,int []in){
        
        if(pre.length==0)  return null;
        
        TreeNode root =new TreeNode(pre[0]);
        
        for(int i=0;i<in.length;i++){
            
            if(in[i]==pre[0]){
                
                root.left=getTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i));
                root.right=getTree(Arrays.copyOfRange(pre,i+1,in.length),Arrays.copyOfRange(in,i+1,in.length));
                break;
            }
        }
        return root;
    }
    
```

#### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {

        if (root == null) {
            return new ArrayList<>();
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        List<Integer> result = new ArrayList<>();

        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                if (i == size - 1) {
                    result.add(node.val);
                }
                if (node.left != null) {
                    q.offer(node.left);
                }
                if (node.right != null) {
                    q.offer(node.right);
                }
            }
        }
        return result;

    }
}
```





#### [7.二叉树的最大深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

```java
//深度优先 
//以root为根的最大深度，为左子树和右子树中最大的深度加1
//时间复杂度O(N)
//空间复杂度O(h)为树的高度
public int maxDepth(TreeNode root) {

        if(root==null) return 0;

        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;

    }

//也可以用广度优先层序遍历

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;

        while(!queue.isEmpty()){
            int size = queue.size();
            result++;
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }

        }
        return result;



    }
}
```

#### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![ex_depth.jpg](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

```java
//深度优先搜索
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {

        if (root == null) {
            return 0;
        }

        int left = minDepth(root.left);
        int right = minDepth(root.right);

        if (left == 0 || right == 0) {
            return Math.max(left, right) + 1;
        }

        return Math.min(left, right) + 1;

    }

}
//层序遍历

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while(!queue.isEmpty()){
            int size = queue.size();
            result++;
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                if(node.left == null && node.right == null){
                    return result;
                }
                if(node.left != null){
                    queue.offer(node.left);
                }
                 if(node.right != null){
                    queue.offer(node.right);
                }
            }

        }
        return result;

    }
}
```

#### [8662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

```java
// 时间复杂度O(N) 遍历每个节点
// 空间复杂度O(N)
public int widthOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        int res = 1;
        LinkedList<TreeNode> queue = new LinkedList<>();
        LinkedList<Integer> indexQueue = new LinkedList<>();
        queue.add(root);
        indexQueue.add(1);
        while (!queue.isEmpty()) {
            int left = indexQueue.peek();
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                TreeNode poll = queue.poll();//当前节点
                Integer index = indexQueue.poll();//当前该节点的索引值
                res = Math.max(res, index - left + 1);//计算当前节点与最左节点的距离
                if (poll.left != null) {
                    queue.add(poll.left);
                    indexQueue.add(index * 2);//左节点的索引值为父节点位置*2
                }
                if (poll.right != null) {
                    queue.add(poll.right);
                    indexQueue.add(index * 2 + 1);//右节点的索引值为父节点位置*2+1
                }
            }
        }
        return res;
    }
```

#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

请实现两个函数，分别用来序列化和反序列化二叉树。

```java
//时间：O(N) 空间O(N)
public class Codec {

    // Encodes a tree to a single string.
    //使用层序遍历将元素加入string中
    public String serialize(TreeNode root) {

        Queue <TreeNode> q = new LinkedList<>();
        q.add(root);
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while(!q.isEmpty()){

            int size = q.size();
            boolean bnull = true;
            for(int i = 0 ; i < size; i++){

                TreeNode node = q.poll();
                
                if(node != null){//如果不为null，就直接加入元素

                    sb.append(node.val + ",");
                    q.add(node.left);
                    q.add(node.right);
                
                }else{//如果为null，

                    sb.append("null,");
                }
            }

        }
        sb.replace(sb.length()-1, sb.length(),"]");

        return new String(sb);
        
    }

    // Decodes your encoded data to tree.
    
    //反序列化
    public TreeNode deserialize(String data) {

        if(data.equals("[null]")) return null;

        String[] s = data.substring(1,data.length()-1).split(",");
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        TreeNode root = new TreeNode(Integer.parseInt(s[0]));
        q.add(root);
        int i = 1;
        while(!q.isEmpty()){

             TreeNode node = q.poll();
             if(!s[i].equals("null")){

                 node.left = new TreeNode(Integer.parseInt(s[i]));
                 q.add(node.left);      
             }
            i++;
             if(!s[i].equals("null")){

                 node.right = new TreeNode(Integer.parseInt(s[i]));
                 q.add(node.right);      
            }
            i++;
                  
        }

        return root;

            
    }
}
```

#### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

```java
/*
1.先序遍历A树的每个结点nA   对应isSubStructure函数
2.判断以nA为根的树是否包含B。对应dfs函数

isSubStructure函数
特例处理:如果A树为空或者B树为空直接返回false
返回值：
1. 以节点 A 为根节点的子树包含树 B ，对应 dfs(A, B)；
2. 树 B 是 树 A 左子树的子结构，对应 isSubStructure(A.left, B)；
3. 树 B 是 树 A 右子树的子结构，对应 isSubStructure(A.right, B)；
以上2，3实际上是在做先序遍历
以上任意一个为true就返回true
dfs函数
终止条件：
当B为空时，说明匹配完成，返回为true;
当A为空或者A结点的值不等于B结点，返回为false;
返回值：判断 A 和 B的左子节点是否相等，即dfs(A.left, B.left) ;
	   判断 A 和 B的右子节点是否相等，即dfs(A.right, B.right);
时间复杂度O(MN):M为A树的结点个数，N为B树的结点个数
空间复杂度 O(M)： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M>N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。
*/
public boolean isSubStructure(TreeNode A, TreeNode B) {

        if(A == null || B == null) return false;

       return dfs(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);

    }
   //判断以A为根节点的树是否包含B
    public boolean dfs(TreeNode A, TreeNode B){

        if(B == null){

            return true;
        }
        if(A == null || A.val != B.val){

            return false;
        }
    
        return dfs(A.left,B.left) && dfs(A.right,B.right);

    }
```

#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

```java
//时间复杂度O(N)
//空间复杂度O(N)
	List<List<Integer>> res;
    List<Integer> path;
    public List<List<Integer>> pathSum(TreeNode root, int target) {

        res = new ArrayList<>();
        path = new ArrayList<>();
        dfs(root,target,0);
        return res;
    }

    public void dfs(TreeNode root,int target,int sum){

        
        if(root == null){
            return;   
        }

        path.add(root.val);
        sum = sum + root.val;
        if(sum == target && root.left == null && root.right == null){//判断是否到叶子结点

            res.add(new ArrayList<>(path));
        }


        dfs(root.left,target,sum);
        dfs(root.right,target,sum);
        path.remove(path.size()-1);

    }
```

#### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![paths-tree.jpg](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    List<String> result;
    public List<String> binaryTreePaths(TreeNode root) {
        result = new ArrayList<>();
        dfs(root,new ArrayList<>());
        return result;
    
    }

    private void dfs(TreeNode node, List<Integer> paths){
        if(node == null){
            return;
        }
        paths.add(node.val);
        if(node.left == null && node.right == null){
            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < paths.size() - 1; i++){
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));
            result.add(new String(sb));
        }
       
        dfs(node.left,paths);
        dfs(node.right,paths);
        paths.remove(paths.size() - 1);


    }
}
```

#### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例 1：**

![leftsum-tree.jpg](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int result = 0;
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null){
            return 0;
        }
        int sum = 0;
        
        if(root.left != null && root.left.left == null && root.left.right == null){
            sum = root.left.val;
        }
        sum += sumOfLeftLeaves(root.left);
        sum += sumOfLeftLeaves(root.right);

        return sum;


    }
}
```

#### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例 1:**

![tree1.jpg](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![tree2.jpg](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int result = 0;
        Queue<TreeNode> queue = new LinkedList<>();

        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (i == 0) {
                    result = node.val;
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

        }
        return result;

    }
}
```

#### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }
        if(root.left == null && root.right == null){
            return root.val == targetSum;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right,targetSum - root.val);


    }
}
```

#### [面试题 04.12. 求和路径](https://leetcode-cn.com/problems/paths-with-sum-lcci/)

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。

```java
int count = 0;
    public int pathSum(TreeNode root, int sum) {

        if(root == null)  return 0;
        dfs(root,0,sum);//
        pathSum(root.left,sum);//以左子树为起点
        pathSum(root.right,sum);//以右子树为起点
        
        return count;

    }

    public void dfs(TreeNode root,int sum,int target){

        if(root == null) return;
        sum = sum + root.val;//加上当前结点
        if(sum == target){//满足条件了就加1

            count++;
        }
        dfs(root.left,sum,target);
        dfs(root.right,sum,target);


    }
```

#### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

//局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！
//从低向上遍历：左右中（后续遍历）
//null节点需要返回有覆盖，这样叶子节点就不会装摄像头了
//如果左右有一个无覆盖，这时候就要装摄像头了
//如果左右都覆盖了，那么这个其实就是无覆盖的（他的父节点装摄像头）
//如果左右有一个有摄像头，那么这个节点其实就被覆盖了
class Solution {
    int result = 0;

    public int minCameraCover(TreeNode root) {
        if (minCamera(root) == 0) {
            result++;
        }
        return result;

    }

    /*
     * 0: 无覆盖
     * 1: 有摄像头
     * 2：有覆盖
     */
    private int minCamera(TreeNode node) {
        if (node == null) {
            return 2;
        }

        int left = minCamera(node.left);
        int right = minCamera(node.right);

        if (left == 0 || right == 0) {
            result++;
            return 1;
        }
        if (left == 2 && right == 2) {
            return 0;
        }
        return 2;

    }
}
```



#### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

```java
//方法1.层序
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null){
            return root2;
        }
        if(root2 == null){
            return root1;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root1);
        queue.offer(root2);

        while(!queue.isEmpty()){
            TreeNode node1= queue.poll();
            TreeNode node2 = queue.poll();

            node1.val += node2.val;
            
            if(node1.left != null && node2.left != null){
                queue.offer(node1.left);
                queue.offer(node2.left);
            }
            if(node1.right != null && node2.right != null){
                queue.offer(node1.right);
                queue.offer(node2.right);
            }
            if(node1.left == null){
                node1.left = node2.left;
            }
            if(node1.right == null){
                node1.right = node2.right;
            }
        }
        return root1;



    }
}

//方法2
class Solution {
    // 递归
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        root1.val += root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    }
}
```

#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

```java
/*终止条件：
1. 当 L和 R同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true；
2. 当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false；
当节点 L 值 != 节点 R 值： 此树不对称，因此返回 false ；
递归
判断两节点 L.left 和 R.right 是否对称；
判断两节点 L.right 和 R.left 是否对称；
返回
两对节点都对称时，才是对称树，因此用与逻辑符 && 连接。
时间复杂度O(N)
空间复杂度O(N)
*/
public boolean isSymmetric(TreeNode root) {

        if(root == null) return true;
        return dfs(root.left,root.right);
    }

    public boolean dfs(TreeNode L,TreeNode R){

        if(L == null && R == null)  return true;
        if(L == null || R == null || L.val != R.val) return false;
        return dfs(L.left, R.right) &&  dfs(L.right,R.left);
    }

//递归

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offerFirst(root.left);
        queue.offerLast(root.right);


        while(!queue.isEmpty()){
            TreeNode leftNode = queue.pollFirst();
            TreeNode rightNode = queue.pollLast();
            if(leftNode == null && rightNode == null){
                continue;
            }
            if(leftNode == null || rightNode == null || leftNode.val != rightNode.val){
                return false;
            }
           queue.offerFirst(leftNode.left);
           queue.offerFirst(leftNode.right);
           queue.offerLast(rightNode.right);
           queue.offerLast(rightNode.left);        
        }
        return true;

        

    }
}
```



## 二叉搜索树

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

![二叉搜索树的后序遍历.png](./images/二叉搜索树的后序遍历.png)

```Java
/*时间复杂度 O(N^2) ： 每次调用recur(i,j) 减去一个根节点，因此递归占用O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用O(N) 。
空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。*/

public boolean verifyPostorder(int[] postorder) {

        return dfs(postorder,0,postorder.length-1);

    }

    public boolean dfs(int []postorder,int i,int j){

        if(i >= j){

            return true;
        }

        int p = i;
        while(postorder[p] < postorder[j]) p++;
        int m = p;
        while(postorder[m] > postorder[j]) m++;

        return m == j && dfs(postorder,i,p-1) && dfs(postorder,p,j-1);
    }
```

#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 ```java
  Node pre,head;
     public Node treeToDoublyList(Node root) {
 
         if(root == null) return null;
         dfs(root);
         pre.right = head;
         head.left = pre;
         return head;    
     }
 
     public void dfs(Node cur){
 
         if(cur == null) return;
 
         dfs(cur.left);
 
         if(pre == null) head = cur;//表示链表刚刚开始形成
         else pre.right = cur;//否则将前一个结点指向当前结点
         cur.left = pre;//将当前结点指向前一个结点
         pre = cur;//更新前一个结点为当前结点
         
         dfs(cur.right);
 
     }
 ```

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第k大的节点。

```java
 //按照右中左的顺序进行遍历
//时间复杂度O(N)
//空间复杂度O(N)

public int res,count;
 public int kthLargest(TreeNode root, int k) {

        count = 0;
        dfs(root,k);
        return res;

    }

    public void dfs(TreeNode root, int k){

        if(root == null)  return;
        dfs(root.right,k);//
        count ++;
        if(count == k){

            res = root.val;
            return;
        }
        
        dfs(root.left,k);
   
    }
```

#### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null){
            return null;
        }

        if(root.val == val){
            return root;
        }else if(root.val < val){
            return searchBST(root.right, val);
        }else{
            return searchBST(root.left, val);
        }

    }
}
```

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。

```java
//时间复杂度O(N) 其中N为二叉树节点树，每循环一轮排除一层，二叉搜索树的层数最小为logN(满二叉树)，最大为N（退化为链表）
//空间复杂度O(N): 最差情况下，即树退化为链表时，递归深度达到树的层数 N 。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        if (root == null || root == p || root == q) {
            return root;
        }

        if (root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        if (root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        return root;

    }
}
```

#### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    int pre = Integer.MAX_VALUE;
    int result = Integer.MAX_VALUE;

    public int getMinimumDifference(TreeNode root) {
        dfs(root);
        return result;
    }

    private void dfs(TreeNode node) {
        if (node == null) {
            return;
        }
        dfs(node.left);
        int curDiff = Math.abs(node.val - pre);
        result = Math.min(result, curDiff);
        pre = node.val;
        dfs(node.right);

    }
}
```



#### [面试题 04.02. 最小高度树](https://leetcode-cn.com/problems/minimum-height-tree-lcci/)

给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

```java
//对于每次递归，选取中间节点作为根节点，数组左侧数据进行递归获取左子树，数据右侧数据进行递归获取右子树
//时间复杂度O(N) 对于每个节点都要进行遍历
//空间复杂度O(logN)
public TreeNode sortedArrayToBST(int[] nums) {

        return dfs(nums,0,nums.length - 1);

    
    }

    public TreeNode dfs(int[] nums,int l,int r){

        if(l > r)  return null;
        int mid = (l + r)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = dfs(nums,l,mid - 1);
        root.right = dfs(nums,mid + 1,r);

        return root;

    }
```

#### [面试题 17.12. 二叉搜索树转链表](https://leetcode-cn.com/problems/binode-lcci/)

二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。

返回转换后的单向链表的头节点。

```java
 TreeNode pre;
    public TreeNode convertBiNode(TreeNode root) {


        pre = new TreeNode(0);
        TreeNode head = pre;
        if(root == null) return null;
        dfs(root);
        return head.right;
    }

    public void dfs(TreeNode cur){

        if(cur == null)  return;

        dfs(cur.left);

        pre.right = cur;
        pre = cur;
        pre.left = null;
        
        dfs(cur.right);

    }
```

#### [面试题 04.05. 合法二叉搜索树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)

实现一个函数，检查一棵二叉树是否为二叉搜索树。

```java
//中序遍历，得到的元素是从小到大的，判断前一个结点是否小于当前结点
//时间复杂度O(N)
//空间复杂度O(N)
	/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        boolean left = isValidBST(root.left);
        if(root.val <= pre){
            return false;
        }
        pre = root.val;
        boolean right = isValidBST(root.right);
        return left && right;
    }
}
```

#### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    int pre = -1;
    int maxCount = 0;
    int curCount = 0;
    List<Integer> result;

    public int[] findMode(TreeNode root) {
        result = new ArrayList<>();
        dfs(root);
        int[] ans = new int[result.size()];
        for (int i = 0; i < result.size(); ++i) {
            ans[i] = result.get(i);
        }
        return ans;

    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        if (root.val == pre) {
            curCount++;
        } else {
            pre = root.val;
            curCount = 1;
        }
        if (curCount == maxCount) {
            result.add(pre);
        } else if (curCount > maxCount) {
            maxCount = curCount;
            result.clear();
            result.add(pre);
        }

        dfs(root.right);
    }
}
```

#### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null){
            TreeNode node = new TreeNode(val);
            return node;       
        }
        if(val < root.val){
            root.left = insertIntoBST(root.left, val);
        }
        if(val > root.val){
            root.right = insertIntoBST(root.right, val);

        }
        return root;    
    }  
}
```

#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**示例 1:**

![del_node_1.jpg](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null){
            return root;
        }

        if(key < root.val){
            root.left = deleteNode(root.left,key);
        }
        if(key > root.val){
            root.right = deleteNode(root.right,key);
        }
      //如果相等，就把左边的节点移到右边节点的最左侧分支下面，然后返回右边节点
        if(key == root.val){
            if(root.left == null){
                return root.right;
            }
            if(root.right == null){
                return root.left;
            }
            TreeNode node = root.right;
            while(node.left != null){
                node = node.left;
            }
            node.left = root.left;
            return root.right;
        }

        return root;

    }
}
```

#### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null){
            return root;
        }

       if(root.val > high){
          return trimBST(root.left,low, high);
       } 
       if(root.val < low){
        return trimBST(root.right,low, high);
       }

       root.left = trimBST(root.left,low, high);
       root.right = trimBST(root.right,low,high);

       return root;
    }
}
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        dfs(root);
        return root;

    }

    public void dfs(TreeNode node) {
        if (node == null) {
            return;
        }
        dfs(node.right);
        sum += node.val;
        node.val = sum;

        dfs(node.left);

    }
}
```

#### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 平衡 二叉搜索树。

**示例 1：**

![btree1.jpg](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![btree.jpg](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return sort(nums, 0, nums.length - 1);

    }

    private TreeNode sort(int[] nums, int startIdx, int endIdx) {
        if (startIdx > endIdx) {
            return null;
        }

        int mid = startIdx + (endIdx - startIdx) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sort(nums, startIdx, mid - 1);
        root.right = sort(nums, mid + 1, endIdx);
        return root;

    }
}
```

#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1

```

```java
//例如：n = 3;
// 1 作为头结点，有dp[2]*dp[0]种情况
// 2作为头节点 有dp[1] * dp[1]种情况
//3作为头结点，有dp[0] * dp[2]种情况
class Solution {
    public int numTrees(int n) {

        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - 1 - j];
            }
        }
        return dp[n];

    }
}
```



## 前缀树

#### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

```java
class TreeNode{

    char val;
    TreeNode [] children = new TreeNode[26];
    boolean isEnd;

    public TreeNode(){

        
    }
    public TreeNode(char val){

        this.val = val;
    }


}
class Trie {

   TreeNode root;

    /** Initialize your data structure here. */
    public Trie() {
        
        root = new TreeNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TreeNode cur = root;
        for(int i = 0; i < word.length();i++){
            char c = word.charAt(i);
            if(cur.children[c - 'a'] == null){//如果包好当前结点的node为null，需要创建一个

                cur.children[c - 'a'] = new TreeNode(c);
             }
            cur = cur.children[c - 'a'];

        }
        cur.isEnd = true;
        

    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        
        TreeNode node = prefixWith(word);
        return node != null && node.isEnd;//如果找到了,返回的node 不为bull同时当前结点为最后的结点

    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {

       
        return prefixWith(prefix) != null;//如果找到了,返回的node 不为bull

    }

    public TreeNode prefixWith(String prefix) {//找到包含前缀的最后一个结点

        TreeNode cur = root;
        for(int i = 0; i < prefix.length();i++){

            char c = prefix.charAt(i);
            if(cur.children[c - 'a'] == null){//为null表示该前缀不存在,返回null

                return null;
            }
            cur = cur.children[c - 'a'];
        }

        return cur;

    }
}
```

## 完全二叉树

#### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

**示例 1：**

![complete.jpg](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

//满二叉树的结点数为：2^depth - 1

class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        TreeNode leftNode = root.left;
        TreeNode rightNode = root.right;
        int leftDepth = 0;// 这里初始为0是有目的的，为了下面求指数方便
        int rightDepth = 0;
        while(leftNode != null){// 求左子树深度
            leftNode = leftNode.left;
            leftDepth++;
        }
          while(rightNode != null){// 求右子树深度
            rightNode = rightNode.right;
            rightDepth++;
        }

        if(rightDepth == leftDepth){//相等表示是满二叉树
            return (2 << leftDepth) - 1;
        }
        return countNodes(root.left) + countNodes(root.right) + 1;


    }
}
```

![image-20240615082636245.png](/Users/yuyingsi/files/资料/Note/doc/数据结构/assets/image-20240615082636245.png)

## 平衡二叉树

#### [8.平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

```java
//时间复杂度O(N)
//空间复杂度O(N)
//终止条件：当root为空时，返回高度为0  当左右子树深度为-1，也就是不是平衡二叉树，就返回-1
//返回值：当前节点左右子树深度差小于等于1,就返回当前左右子树深度最大值加1,否则说明不是平衡二叉树，就返回-1

public boolean isBalanced(TreeNode root) {

         return getHeight(root)!=-1;

    
    }
    public int getHeight(TreeNode root){

        if(root==null) return 0;
        int left=dfs(root.left);//计算左子树的深度（-1表示不是平衡二叉树，直接返回）
        if(left==-1) return -1;
        int right=dfs(root.right);//计算右子树的深度（-1表示不是平衡二叉树，直接返回）
        if(right==-1) return -1;

        return Math.abs(right-left)<=1 ? Math.max(left,right)+1:-1;//如果左右高度差小于2表示是平衡二叉树，就返回高度，否则不是，返回-1
        


    }
```

