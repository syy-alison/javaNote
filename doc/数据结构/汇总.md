[TOC]



#### [1. 青蛙跳台阶](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```java
//时间复杂度:O(N)
//空间复杂度O(1)
public int JumpFloor(int target) {
        
    int a=1,b=1,sum;
    for(int i=0;i<target;i++){
        
        sum=a+b;
        a=b;
        b=sum;
    }
    
    return a;
}
```

#### [2.斐波那契数列]()

```java 
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - ja2), 其中 N > 1.
```

```java
 public int Fibonacci(int n) {
        
        int a=0;
        int b=1;
        for(int i=0;i<n;i++){
            
            int sum=a+b;
            a=b;
            b=sum;
        }
        
        return a;
        
        

    }
```

#### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

```java
//使用&& 运算短路
//时间复杂度O(N)
//空间复杂度O(N)
public int sumNums(int n) {

        boolean x = (n > 1) && (n += sumNums(n - 1)) > 0;
        return n;


    }
```

#### [1.子数组的最大累加和问题](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/)

给定一个数组arr，返回子数组的最大累加和

例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.

题目保证没有全为负数的数据

[要求]

时间复杂度为O(n)，空间复杂度为O(1)

![](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\子数组的最大累加和问题.png)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        for(int i = 1; i < nums.length; i++) {
            nums[i] += Math.max(nums[i - 1], 0);//如果i之前的数据相加小于0，则重新开始累加，否则继续累加
            res = Math.max(res, nums[i]);
        }
        return res;
    }
}
```

#### [2.最长递增子序列](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=196&tqId=37129&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)

给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）

输入：[2,1,5,3,6,4,8,9,7]

输出：[1,3,4,8,9]

参考：https://blog.nowcoder.net/n/843a7ed318984a36946ac7b01b5f00d9

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\最长上升子序列.jpg](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\最长上升子序列.jpg)

```java
//思路： 维护一个序列temp,每遍历到数组的第i个元素e，如果e比最后一个元素大，就直接加入temp中，同时nums[i]表示e在temp数组中的下标。如果e比最后一个元素小，那么就遍历temp数组，从左往右找第一个比e大的数据，并用e替换该元素。
//遍历完之后，从左往右遍历nums数组，标号从大到小，然后填入我们最终的结果.
//时间复杂度O(nlogn)
//空间复杂度O(n)
public int[] LIS (int[] arr) {
        // write code here
        int n=arr.length;
        int []nums=new int[n];
        int []temp=new int[n];
        temp[0]=arr[0];
        nums[0]=0;
        int tempIdx=0;
        for(int i=1;i<n;i++){
            
            if(arr[i]>temp[tempIdx]){
                
                tempIdx++;
                temp[tempIdx]=arr[i];
                nums[i]=tempIdx;
            }else{
                
                int l=0;
                int r=tempIdx;
                while(l<=r){
                    
                    int mid=(l+r)/2;
                    if(arr[i]>=temp[mid]){
                        
                        l=mid+1;
                    }else{
                        
                        r=mid-1;
                    }
                }
                temp[l]=arr[i];
                nums[i]=l;
                
            }
            
        }
        int []res=new int[tempIdx+1];
        for(int i=nums.length-1;i>=0;i--){
            
            if(nums[i]==tempIdx){
                
                res[tempIdx]=arr[i];
                tempIdx--;
            }
            
           
        }
         return res;
    }
```

#### [3.矩阵的最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 m*n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

```java
//时间复杂度O(MN)
//空间复杂度O(MN)
public int minPathSum(int[][] grid) {

        int nr=grid.length;
        int nc=grid[0].length;

        int[][]dp=new int[nr][nc];
        for(int i=0;i<nr;i++){

            for(int j=0;j<nc;j++){
 
                if(i==0 && j==0)  dp[i][j]=grid[0][0];
                else if(i==0)  dp[i][j]=dp[i][j-1]+grid[i][j];
                else if(j==0) dp[i][j]=dp[i-1][j]+grid[i][j];
                else {

                    dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
                }
                
            }
        }

        return dp[nr-1][nc-1];

    }
```

#### [4.打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```java
//动态规划：设置偷到第i个房间最大能偷dp[i]
//dp[i]=Math.max(dp[i-2]+nums[i],dp[i]);
//时间复杂度O(N)
//空间复杂度O(1)
public int rob(int[] nums) {
        if(nums.length==0) return 0;

        int pre1=0;
        int pre2=0;
        for(int i=0;i<nums.length;i++){
            int temp=pre2;
            pre2=Math.max(pre1+nums[i],pre2);
            pre1=temp;


        }

        return pre2;

    }
```

#### [5.打家劫舍(环形)](https://leetcode-cn.com/problems/house-robber-ii/submissions/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

```java
//分为第一个偷，最后一个不偷和第一个不偷，最后一个偷的情况
//时间复杂度O(N)空间复杂度O(1)
public int rob(int[] nums) {

        if(nums.length==0) return 0;
        if(nums.length==1) return nums[0];
        return Math.max(help(nums, 1,nums.length-1),help(nums, 0,nums.length-2));

    }

    public int help(int []nums,int l,int r){

        int pre1=0;
        int pre2=0;
        for(int i=l;i<=r;i++){

            int temp=pre2;
            pre2=Math.max(pre1+nums[i],pre2);
            pre1=temp;
        }

        return pre2;
    }
```

#### [6.数组区间和](https://leetcode-cn.com/problems/range-sum-query-immutable/)

给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。

实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）

```java
//求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。
//时间复杂度O(N)
//空间复杂度O(N)
public int[] numbers;

    public NumArray(int[] nums) {

        numbers=new int[nums.length+1];
        for(int i=1;i<=nums.length;i++){

            numbers[i]=numbers[i-1]+nums[i-1];//number[i]为0~i-1的和
        }
    }
    
    public int sumRange(int left, int right) {

           return numbers[right+1]-numbers[left];

    }
```

#### [7.数组中等差递增子区间的个数](https://leetcode-cn.com/problems/arithmetic-slices/)

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

函数要返回数组 A 中所有为等差数组的子数组个数。

```java
//对于数组[3,4,5,6,7,8]   dp[i]表示以i结尾的等差数列的子数组个数
//dp[2]=1   3,4,5
//dp[3]=2   3，4，5，6   4，5，6
//dp[4]=3   3,4,5,6,7   4,5,6,7   5,6,7
//dp[5]=4   3,4,5,6,7,8   4,5,6,7,8   5,6,7,8  6,7,8
     
public int numberOfArithmeticSlices(int[] nums) {
        int dp=0;
        int res=0;
        for(int i=2;i<nums.length;i++){

            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]) 
            {
                dp=dp+1;
            }else{

                dp=0;
            }
            res=res+dp;

        }
        return res;

    }
```

#### [8.整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```java
//创建数组dp,其中dp[i]表示将正整数i拆分成至少两个正整数的和之后，这些正整数的最大的乘积，因此dp[0]=dp[1]=0;
//当i>=2时，假设对正整数i拆分出的第一个正整数是j,则有两种情况：
//- 将i拆分成j和i-j的和，且i-j不再拆分成多个正整数，此时的乘积是j*(i-j)
//- 将i拆分成j和i-j的和，且i-j继续拆分成多个正整数，此时的乘积是j*dp[i-j]
//因此dp[i]=Math.max(j * dp[i - j], j * (i - j))
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i - 1; j++) {
            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));
        }
    }
    return dp[n];
}
```

#### [9.完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

```java
//依次计算n=1,n=2,n=3...的最小的数量dp[i]
//对于dp[i]  它可以等于一个完全平方数（temp）和另外一个数据相加,另一个数据的最小平方数量是dp[i-temp],我们遍历所有小于i的平方数，取数量最小的那个也就是Min(dp[i-temp]+1)
//时间复杂度O(n*sqrt(n))
//空间复杂度O(N)
public int numSquares(int n) {

        int sqrnum=(int)Math.sqrt(n);
        int[] sqr=new int[sqrnum];
        for(int i=1;i<=sqrnum;i++){

              sqr[i-1]=i*i;      //先找出所有的平方数
        }
        
        int []dp=new int[n+1];
    //依次求出
        for(int i=1;i<=n;i++){
            int min=Integer.MAX_VALUE;
            for(int temp:sqr){

                if(temp > i){

                    break;
                }
                min=Math.min(min,dp[i-temp]+1);//取数量最小的
            
            }
            dp[i]=min;
        }

    return dp[n];
    }
```

#### [10.解码方法](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"111" 可以将 "1" 中的每个 "1" 映射为 "A" ，从而得到 "AAA" ，或者可以将 "11" 和 "1"（分别为 "K" 和 "A" ）映射为 "KA" 。注意，"06" 不能映射为 "F" ，因为 "6" 和 "06" 不同。

给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

```java
//若s[i]=0:  若 1<=s[i-1]<=2   则i和i-1位必须组合，dp[i]=dp[i-1]; 否则返回0
//若s[i-1]=1  则i和i-1位可以不组合,有dp[i-1]种情况，也可以组合，有dp[i-2]种情况，dp[i]=dp[i-1]+dp[i-2];
//若s[i-1]=2  且1<=s[i]<=6 同上面一种情况 dp[i]=dp[i-1]+dp[i-2];
//其他情况只能不组合,dp[i]=dp[i-1];
//时间复杂度O(N)
//空间复杂度O(1)
 
public int numDecodings(String s) {
        
        if(s.charAt(0)=='0') return 0;
        int pre=0;
        int dp1=0;
        int dp2=1;
         
        for(int i=1;i<=s.length();i++){

            int temp=s.charAt(i-1)-'0';
            int dp=dp2;
            if(temp==0 && pre<=2 && pre > 0){

                dp2=dp1;
                 
            }else if(temp==0){

                return 0;

            }else if(pre==1 || (pre==2 && temp<=6 && temp>0)){

                dp2=dp1+dp2;
            }

            pre=temp;
            dp1=dp;
            
        }

        return dp2;

    }
```

#### [11. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。

给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

```java
//时间复杂度O(N^2)
//空间复杂度O(N)
//根据数对的第一个数排序所有的数对，dp[i] 存储以 pairs[i] 结尾的最长链的长度。当 i < j 且 pairs[i][1] < pairs[j][0] 时，扩展数对链，更新 dp[j] = max(dp[j], dp[i] + 1)。
public int findLongestChain(int[][] pairs) {

        Arrays.sort(pairs,(a,b)->a[1]-b[1]);
        int N=pairs.length;
        int []dp=new int[N];
        int res=1;
        Arrays.fill(dp,1);

        for(int j=1;j<N;j++){

            for(int i=0;i<j;i++){

                if(pairs[j][0]>pairs[i][1]){

                    dp[j]=Math.max(dp[j],dp[i]+1);
                }      
            }
        }

        for(int i=0;i<N;i++){

            res=Math.max(res,dp[i]);
        }
        
        return res;

    }
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```java
//时间复杂度O(MN)
//空间复杂度O(MN)
//dp[i][j]表示text1[0:i]和 text1[0:j]的最长公共子序列
//若text1[i-1]=text2[j-1]  则dp[i][j]=dp[i-1][j-1]
//若text1[i-1]!=text2[j-1]  则dp[i][j]=ath.max(dp[i-1][j],dp[i][j-1]);

public int longestCommonSubsequence(String text1, String text2) {

            int len1=text1.length();
            int len2=text2.length();
            int[][]dp=new int[len1+1][len2+1];

            for(int i=1;i<=len1;i++){
                char temp1=text1.charAt(i-1);
                for(int j=1;j<=len2;j++){
                    char temp2=text2.charAt(j-1);
                    if(temp1==temp2){

                        dp[i][j]=dp[i-1][j-1]+1;
                    }else{

                        dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
                    }
                }
            }

            return dp[len1][len2];

        

    }
```

#### 12.[0-1背包问题](https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg)

有N件物品和一个容量是V的背包。每件物品有且只有一件。

第i件物品的体积是 vi，价值是wi 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

```java
//思路：dp[i][c]表示考虑前i件物品，使用容量不超过c的条件下的背包最大价值。
//转移方程：当不加入第i件，则当前dp[i][c]=dp[i-1][c]
//        当加入第i件，则只有此刻容量c>=v[i]才能加进去,加进去之后留给前i-1件就剩c-v[i]的容量了，则当前最大价值就是dp[i][c]=dp[i-1][c-v[i]+w[i]
//也就是dp[i][c]=Math.max(dp[i-1][c],dp[i-1][c-v[i]+w[i])
//时间复杂度O(N*c)
//空间复杂度O(N*c)
public int maxValue(int N, int C, int[] v, int[] w) {
        int[][] dp = new int[N][C+1];
        // 先处理「考虑第一件物品」的情况
        for (int i = 0; i <= C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        // 再处理「考虑其余物品」的情况
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < C + 1; j++) {
                // 不选该物品
                int n = dp[i-1][j]; 
                // 选择该物品，前提「剩余容量」大于等于「物品体积」
                int y = j >= v[i] ? dp[i-1][j-v[i]] + w[i] : 0; 
                dp[i][j] = Math.max(n, y);
            }
        }
        return dp[N-1][C];
    }
}
//由于当前dp[i][c]只与dp[i-1][c]和dp[i-1][c-v[i]]有关，所以可以继续优化
//假设第i行的结果集为dp[0:c]
//这时候我们要求第i+1行的dp[0:c],我们只能从后往前进行计算，因为如果从前往后计算的话，dp[k]=dp[c-v[k]]中dp[c-v[k]]的值其实是第i+1行的值，但是正确的应该是第i行的值。所以要从后往前进行计算。
 public int maxValue(int N, int C, int[] v, int[] w) {
        int[] dp = new int[C + 1];
        for (int i = 0; i < N; i++) {
            for (int j = C; j >= v[i]; j--) {
                // 不选该物品
                int n = dp[j]; 
                // 选择该物品
                int y = dp[j-v[i]] + w[i]; 
                dp[j] = Math.max(n, y);
            }
        }
        return dp[C];
    }

```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

```java
//题目可以转化为是否可以在数组中找到一些数，使得这些数的总和为数组总和的一半
//dp[i][j] 表示nums[0:i]中是否有一些数的和为j
//初始状态：对于dp[i][0]一直都为true，因为可以不选择任意一个数据，这样就可以满足和为0
//转移方程：对于dp[i][j]我们可不选择nums[i]，则dp[i][j]=dp[i-1][j],我们也可以选择nums[i],则dp[i][j]=dp[i-1][j-nums[i]];
//这样dp[i][j]=dp[i-1][j]|dp[i-1][j-nums[i]]
//由于dp[i][j]只与i-1行有关系，所以可以转化为一维数组
//时间复杂度O(N*target)
//空间复杂度O(target)
public boolean canPartition(int[] nums) {
        int n=nums.length;
        if(n == 1) return false;
        int sum=0;
        for(int i=0;i<n;i++){

            sum+=nums[i];
     
        }
        
        if(sum %2 != 0)  return false;
        int target=sum/2;
        boolean []dp=new boolean[target+1];
        dp[0]=true;
        for(int i=0; i < n;i++){
            int num=nums[i];
            for(int j = target; j>=num; j--){

                  dp[j]|=dp[j-num];
             }
        }

        return dp[target];       

    }  
```

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

```java
//设正数和为sum(P),负数和为sum(N)
//sum(p)-sum(N)=target
//sum(p)+sum(N)+sum(P)-sum(N)=target+sum
//sum(p)=(target+sum)/2
//也就是要在数组中找到一些数和为(target+sum)/2，同时(target+sum)需要为偶数
//转换为0-1背包问题
//dp[i][j]表示nums[0:i]中和为j的组合数
//dp[i][0]表示nums[0:i]中和为0的数，这时候可以都不选，也就是其他数全设为负数 也就是dp[i][0]=1
//转移方程：当不选择nums[i]时，dp[i][j]=dp[i-1][j]，当选择nums[i]时，dp[i][j]=dp[i-1][j-nums[i]],这样一共有dp[i-1][j]+dp[i-1][j-nums[i]]种情况
//优化：转化一维数组代码如下
//时间复杂度：O((target+sum)*N)
//空间复杂度：O((target+sum))
public int findTargetSumWays(int[] nums, int target) {

        int n=nums.length; 
        int sum=0;
        
        for(int i=0;i<n;i++){

             sum+=nums[i];
        }

        if(sum<target || (target+sum)%2==1) 
        return 0;
    
        int targettemp=(target+sum)/2;
        int []dp=new int[targettemp+1];
        dp[0]=1;
        for(int i=0;i<n;i++){
            int num=nums[i];
            for(int j=targettemp;j>=num;j--){

                dp[j]=dp[j]+dp[j-num];
            }
        }

        return dp[targettemp];

    }

//第二种解法dsf
 int count=0;
    public void dfs(int target,int i,int []nums,int sum){

        if(i==nums.length){

            if(sum==target) count++;
            return;
        }

        dfs(target,i+1,nums,sum+nums[i]);
        dfs(target,i+1,nums,sum-nums[i]);
    


    }
    
    public int findTargetSumWays(int[] nums, int target) {

       dfs(target, 0,nums,0);
       return count;

    }
```

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

```java
//问题可以转化为0-1背包问题
//dp[i][j][k]表示str[0:i]中最多有j个0和k个1的最大子集的大小
//初始状态：dp[0][j][k]=0 也就是什么都不选，子集大小自然就等于0
//转移方程:如果选择str[i]  dp[i][j][k]=dp[i-1][j-zero][k-one]+1  如果不选择则dp[i][j][k]=dp[i-1][j][k],二者取最大。
//优化:转化一维数组代码如下
//时间复杂度O(mnl)
//空间复杂度O(mn)
public int findMaxForm(String[] strs, int m, int n) {


        if(strs==null || strs.length==0) return 0;
        int [][]dp=new int[m+1][n+1];

        for(String s:strs){

            int one=0;
            int zero=0;

            for(int i=0;i<s.length();i++){

                if(s.charAt(i)=='1'){

                    one++;
                }else{

                    zero++;
                }      
            }

            for(int j=m;j>=zero;j--){
                for(int k=n;k>=one;k--){

                    dp[j][k]=Math.max(dp[j][k],dp[j-zero][k-one]+1);
                }
            }
        }

        return dp[m][n];



    }
```

#### 13.[完全背包问题](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486107&idx=1&sn=e5fa523008fc5588737b7ed801caf4c3&chksm=fd9ca184caeb28926959c0987208a3932ed9c965267ed366b5b82a6fc16d42f1ff40c29db5f1&scene=178&cur_album_id=1751702161341628417#rd)

有N种物品和一个容量为C的背包，每种物品都有无限件。

第i 件物品的体积是 v[i]，价值是 w[i]。

求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

其实就是在 0-1 背包问题的基础上，增加了每件物品可以选择多次的特点（在容量允许的情况下）。

![](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\完全背包问题.png)

```java
/*
思路:dp[i][j]表示考虑前i件物品，放入一个容量为j的背包可以获取的最大价值。
初始状态：当只有一个物件的时候，dp[0][j]=j/v[0]*w[0]
转移方程：由于每个物件可以被选择多次，因此对于某个dp[i][j]而言，他的值为以下方案的最大值
选择0件物品i的最大价值 dp[i-1][j]
选择1件物品i的最大价值，dp[i-1][j-v[i]]+w[i]
...
选择k件物品i的最大价值，dp[i-1][j-k*v[i]]+K*w[i]
则转移方程为dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i],..dp[i-1][j-k*v[i]]+K*w[i])   0<=k*v[i]<=j
dp[i][j-v[i]]=max(dp[i-1][j-v[i]]+w[i],..dp[i-1][j-k*v[i]]+K*w[i])   0<=k*v[i]<=j
也就是dp[i][j]=max(dp[i-1][j],dp[i][j-v[i]]+w[i])
也就是dp[i][j]的值与上一行的dp[j]的值有关以及当前行的dp[j-v[i]]+w[i]有关
由于与当前行的dp[j-v[i]]+w[i]有关，所以需要从小到大遍历先计算出前面的值，这样才能得到正确的结果
dp[j]=max(dp[j],dp[j-v[i]]+w[i])
*/

public int maxValue(int N, int C, int[] v, int[] w) {
        int[] dp = new int[C + 1];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j <= C; j++) {
                // 不考虑第 i 件物品的情况（选择 0 件物品 i）
                int n = dp[j];
                // 考虑第 i 件物品的情况
                int y = j - v[i] >= 0 ? dp[j - v[i]] + w[i] : 0; 
                dp[j] = Math.max(n, y);
            }
        }
        return dp[C];
    }
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

```java 
/*
每种硬币的数量是无限的，可以理解为一个完全背包问题
初始状态：初始化dp数组：因为硬币的数量一定不会超过amount，而amount <= 10^4
 ，因此初始化数组值为10001；dp[0] = 0
 返回dp[amount]，如果dp[amount]的值为10001没有变过，说明找不到硬币组合，返回-1
*/

 public int coinChange(int[] coins, int amount) {

        int N = coins.length;
        int []dp = new int[amount + 1];
        Arrays.fill(dp,1001);//
        dp[0] = 0;

        for (int i = 0; i < N; i++) {
            for (int j = coins[i]; j <= amount; j++) {

                dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);

            }
        }

        return dp[amount] != 1001 ? dp[amount]:-1;
    }
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

```java
//dp[i][j]表示coins[0:i]中可以凑成j的组合数
//初始状态dp[0][0]=1 表示没有硬币，凑成0的组合数为0
//dp[0][1:j]=0 没有任何组合
//转移方程： dp[i] = dp[i] + dp[i - coin];
public int change(int amount, int[] coins) {


        int []dp = new int[amount+1];
        dp[0] = 1;
        for(int coin : coins){
            for(int i = coin; i <= amount; i++){

                dp[i] = dp[i] + dp[i - coin];

            }
        }

       return dp[amount]; 

    }
```

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```java
//设dp[i]为以nums[i]为结尾的和的最大的值
//dp[i-1]<=0 说明前面的数据没有贡献或者为负贡献，直接设dp[i]=nums[i]然后相加
//dp[i-1] > 0 dp[i]=dp[i-1]+nums[i]
//可以用nums[i]代表dp[i]
//时间复杂度O(N)
//空间复杂度O(1)
    public int maxSubArray(int[] nums) {

        int res = nums[0];
        for(int i = 1; i < nums.length;i++){

                if(nums[i-1] > 0) {

                    nums[i] = nums[i-1] + nums[i];
                }
                
                 res = Math.max(res,nums[i]);
        }
    	return res;
        
    }
```

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```java
//dp[i] 表示以i结尾的字符可以翻译的方法个数
//当s[i-1]=1 或者s[i-1]=2 && s[i]=0~5时，dp[i] = dp[i-1]+dp[i-2] 也就是当s[i]单独一个组合，方法数为dp[i-1]当s[i]与s[i-1]组合，方法数为dp[i-2];
//其他情况dp[i]=dp[i-1];
//时间复杂度O(N)空间复杂度O(1)
public int translateNum(int num) {
  
       String s = String.valueOf(num);
       int dp0 = 1;
       int dp1 = 1;
       for(int i = 1; i < s.length(); i++){

           char c1 = s.charAt(i);
           char c0 = s.charAt(i-1);
           if(c0 == '1' ||(c0 == '2' && c1 <= '5')){//
               
               int temp = dp0;
               dp0 = dp1;
               dp1 = dp1 + temp;

            }else{ 
                   
                dp1 = dp1;
                dp0 = dp1;

                } 
       }

       return dp1;


    }
```

#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\骰子问题.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\骰子问题.png)

```java
//设i个骰子和为j的概率为dp[i][j]
//dp[i][j]=dp[i-1][j-1]*1/6 +dp[i-1][j-2]*1/6 + dp[i-1][j-3]*1/6.... 
//比如说dp[2][3]  有几种情况：第一个筛子和为2，第二个骰子为1，也就是dp[1][2]*1/6,第一个筛子和为1，第二个骰子为2，也就是dp[1][1]*1/6.
//dp[i][j] = ∑(k=1~6)dp[i-1][j-k]*1/6  这时候会有边界问题，也就是当j<6时，k其实不需要到6，比如dp[2][3]=dp[1][2]+dp[1][1]+dp[1][0]+dp[1][-1]+dp[1][-2]+dp[1][-3],dp[1][1]后面的dp其实是不存在的。
//其实对于dp[i-1][j] 他只会对dp[j][j+1],dp[j][j+2],dp[j][j+3],dp[j][j+4],dp[j][j+5],dp[j][j+6]有贡献。
//时间复杂度 O(N^2) 状态转移循环 n - 1 轮；每轮中，当 i = 2, 3, ..., n时，对应循环数量分别为 6×6,11×6,...,[5(n−1)+1]×6 ，因此总体复杂度为O((n - 1) O((n−1)× 6*(6+[5(n−1)+1])/2).
//状态转移过程中，辅助数组 tmp 最大长度为 6(n-1) - [(n-1) - 1] =5n−4 ，因此使用 O(5n - 4) = O(n)大小的额外空间。
public double[] dicesProbability(int n) {

        double[]dp = new double[6];
        Arrays.fill(dp, 1.0/6.0);//初始状态，骰子有一个

        for(int i = 2; i <=n;i++){//当骰子有两个，有三个。。。有n个时

            double[] temp = new double[5 * i + 1];//对于有i个骰子，他的取值范围为[n,6n]，一共有5n+1种情况

            for(int j = 0; j < dp.length; j++){//遍历dp[i-1][j]

                for(int k = 0; k < 6; k++){//

                    temp[j+k] += dp[j]/6.0;
                }

            }
            dp = temp;
        }

        return dp;
    }

```

#### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

```java
/*丑数的排列为1,2,3,4,5,6,8,10.... 任意一个丑数等于小于他的某一个丑数*2,*3,*5得到，也就是
A=[1*2,2*2,3*2,4*2.....]
B=[1*3,2*3,3*3,4*3.....]
C=[1*5,2*5,3*5,4*5.....]
也就是丑数是上面三个集合合并，去重，排序后得到
也就是有a,b,c三个指针，分别指向A,B,C
比较A[a],A[b],A[c]的大小，选取最小的一个数，这样可以实现排序
每选完一个数，就需要判断A[a],A[b],A[c]的值是否等于我们选取的这个数，如果是，指针就加1，这样就实现了去重。
时间复杂度O(N)
空间复杂度O(N)
*/
public int nthUglyNumber(int n) {

        int[] dp = new int[n];
        dp[0] = 1;
        int a = 0, b = 0, c = 0;
        for(int i = 1; i < n; i++){

            int a2 = dp[a] * 2, a3 = dp[b] * 3, a5 = dp[c] * 5;
            dp[i] = Math.min(Math.min(a2,a3),a5);
            if(dp[i] == a2) a++;
            if(dp[i] == a3) b++;
            if(dp[i] == a5) c++;
        }

        return dp[n-1];
    }
```

#### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

```java
/*dp[i][j]表示p(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j)时能拿到礼物的最大累计价值。
时间复杂度O(MN)
空间复杂度O(1)
*/

public int maxValue(int[][] grid) {

        int r = grid.length;
        int c = grid[0].length;
  
        
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){

                if(i == 0 && j == 0) continue;;//起始元素
                else if(i == 0) grid[i][j] = grid[i][j-1] + grid[i][j];//只能从左边到
                else if(j == 0) grid[i][j] = grid[i-1][j] + grid[i][j];//只能从上边到
                else{

                    grid[i][j] = Math.max(grid[i-1][j],grid[i][j-1]) + grid[i][j];//从左边或者上面到，取最大值
                }
            }
        }
        return grid[r-1][c-1];

    }
```

#### [1. 求平方根](https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/)

```java
//时间复杂度O(logx)
//空间复杂度O(1)
public int sqrt (int x) {
        // write code here
        
        int res=0;
        int l=0;
        int r=x;
        while(l<=r){
            
            int mid=l+(r-l)/2;
            if((long)mid*mid<=x){
                
                res=mid;
                l=mid+1;
            }
            else 
            {
                r=mid-1;
            }
            
        }   
        return res;
    }
```

#### [在转动过的有序数组中寻找目标值](https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707?tpId=196&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

```java
    public int search (int[] A, int target) {
        // write code here
        int l=0;
        int r=A.length-1;
        while(l<=r){
            
            int mid=l+(r-l)/2;
            if(A[mid]==target) return mid;
            if(A[mid]>=A[l]){//左侧有序
                
                if(A[mid]>target && A[l]<=target){//如果满足条件，说明在左侧中
                    
                    r=mid-1;
                }else{//否则在右侧
                    
                    l=mid+1;
                }
                   
            }else{//右侧有序
                
                if(A[mid]<target && A[r]>=target){//如果满足条件，说明在右侧中
                    
                    l=mid+1;
                }else{
                    
                    r=mid-1;
                }
            }
            
            
        }
        return -1;
    }
            
```

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给出一个整数数组，请在数组中找出两个加起来等于目标值的数，

你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的

假设给出的数组中只存在唯一解。

```java
//时间复杂度：O(N)
//空间复杂度O(N)
public int[] twoSum (int[] numbers, int target) {
        // write code here
        
        Map<Integer,Integer> map=new HashMap<Integer,Integer>();
        int []res=new int[2];
        for(int i=0;i<numbers.length;i++){
            
            if (map.containsKey(target-numbers[i])){//如果map中存在target-该数
                
               res[0]=map.get(target-numbers[i])+1; 
               res[1]=i+1;
               return res;//直接返回
               
            }else{
                
                map.put(numbers[i],i);//不然就加到map中
            } 
        }
        
        return res;
        
        
    }
```

#### [1.LRU缓存结构](https://leetcode-cn.com/problems/lru-cache-lcci/solution/lruhuan-cun-by-leetcode-solution/)

设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能

- set(key, value)：将记录(key, value)插入该结构
- get(key)：返回key对应的value值

[要求]

1. set和get方法的时间复杂度为O(1)
2. 某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。
3. 当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。

若opt=1，接下来两个整数x, y，表示set(x, y)
若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1
对于每个操作2，输出一个答案

```java
import java.util.*;
//定义一个双向链表，存储key值和value值
class LinkedNode{
       int val;
       int key;
       LinkedNode next;
       LinkedNode pre;
       public LinkedNode(int _key,int _val){
            key=_key;
            val=_val;
        }
    }
public class Solution {
   
    public Map<Integer,LinkedNode>cache=new HashMap<Integer,LinkedNode>();//hashMap：存储key，和链表
    public LinkedNode head;//定义一个伪头节点
    public LinkedNode tail;//定义一个尾节点
    public int[] LRU (int[][] operators, int k) {
       
        // write code here
        head=new LinkedNode(0,0);//初始化头节点
        tail=new LinkedNode(0,0);//初始化尾节点
        head.next=tail; 
        tail.pre=head;
        ArrayList<Integer>list=new ArrayList<Integer>();//用来存结果
        
        for(int i=0;i<operators.length;i++){    
            int opt=operators[i][0];
 
            switch(opt){       
                case 1:
                    set(operators[i][1],operators[i][2],k);//添加值
                break;
                case 2:
                    list.add(get(operators[i][1])); //取出值
                break;
                default:
                 
            }       
        
        }
        //将list转数组
        int []res=new int [list.size()];
        int i=0;
        for(int val:list){
            
            res[i++]=val;
        }
        
        return res;
                    
    }
    
    public void set(int key,int value,int k){
        LinkedNode tempnode=cache.get(key);//先看一下hashmap中有没有这个元素
        if(tempnode == null){//如果没有就添加
            
            LinkedNode node=new LinkedNode(key,value);
            if(cache.size()==k)  RemmoveTail();//如果大小超过指定容量，需要将最后一个节点移除
            AddToHead(node);//在链表中添加节点
            cache.put(key,node);//将键值存入缓存中
        }else{//如果有就改变key的value，并添加到头部
            
            tempnode.val=value;
            if(tempnode.pre!=head) MoveToHead(tempnode);
        }
          
    }
    
    public int get(int key){
        
        LinkedNode node=cache.get(key);//先看一下有没有
        if(node==null){//如果没有直接返回1
            
            return -1;
        } 
        if(node.pre!=head) MoveToHead(node);//如果有就添加到头部
        return node.val;
    }
    
    public void MoveToHead(LinkedNode node){
        
       
        //LinkedNode tailtemp=node.pre;
        //tailtemp.next=tail;
        //tail.pre=tailtemp;  这个有错误，因为不一定是从结尾移过来的，可以是任意位置
        RemoveNode(node);
        AddToHead(node);
        
        
    }
    public void RemoveNode(LinkedNode node){
             
        node.pre.next=node.next;
        node.next.pre=node.pre;
          
    }
    
     public void AddToHead(LinkedNode node){
        
  
        node.pre=head;
        node.next=head.next;
        head.next.pre=node;  
        head.next=node;
       
    }
    
    public void RemmoveTail(){//将最后尾部元素移除
        LinkedNode temp=tail.pre;
        RemoveNode(temp);
        cache.remove(temp.key);
       
        
    }
}
```

#### [1. 链表反转](https://leetcode-cn.com/problems/reverse-linked-list/)

输入一个链表，反转链表后，输出新链表的表头。

```java
//时间复杂度O(N) 需要遍历每个节点
//空间复杂度O(1)
public static ListNode ReverseList(ListNode head) {
        
        ListNode node=null; //先定义一个空节点
        
        while(head!=null){  
            
            ListNode next=head.next; //保存下一个节点
            head.next=node;//当前节点指向上一个节点
            node=head;//作为下一轮反转的上一个节点
            head=next;//继续往下走
        } 
        return node;    
    }
```

#### [2.判断链表是否有环](https://leetcode-cn.com/problems/linked-list-cycle/)

判断给定的链表中是否有环。如果有环则返回true，否则返回false。

你能给出空间复杂度O(1)的解法么？

![](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\快慢指针.png)

```java
//时间复杂度O(N)
//空间复杂度O(1)
public boolean hasCycle(ListNode head) {
        
        if(head==null || head.next==null)  return false;
        ListNode slow=head;//慢指针
        ListNode fast=head.next;//快指针
        while(fast!=null && fast.next!=null){
            
            if(slow==fast)  return true;
            slow=slow.next;//每次走一步
            fast=fast.next.next;//每次走两步
            
        }
        
        return false;
    }
```

#### [3. 合并两个有序链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的，且合并后新链表依然有序。

```java
//时间复杂度：O(N+M)
//空间夫复杂度：O(1)
public ListNode mergeTwoLists (ListNode l1, ListNode l2) {
        // write code here
        
        if(l1==null && l2==null) return l1;
        else if(l1==null) return l2;
        else if(l2==null) return l1;
        
        ListNode node= new ListNode(0);
        ListNode head=node;
        while(l1!=null && l2!=null){
            
            if(l1.val<=l2.val){
                
                node.next=l1;
                l1=l1.next;
                
            }else{   
                node.next=l2;
                l2=l2.next;
            }
            node=node.next;     
            
        }
        if(l1!=null){
            node.next=l1;
        }else if(l2!=null){
            
            node.next=l2;
        }
        
        return head.next;
        
    }
```

#### [4.链表中的节点每K个一组翻转](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/)

```java
//时间复杂度：O(N)
//空间复杂度O(1)
public ListNode reverseKGroup (ListNode head, int k) {
        // write code here  
            ListNode hair=new ListNode(0);//伪头节点
            hair.next=head;
            ListNode pre=hair;
        
            int i=0;
            while(head!=null && i<k){
                    
                if(i<k-1){
                    head=head.next;
                    i++;
                }
                else if(i==k-1){
                    
                    i=0;
                    ListNode next=head.next;
                    ListNode[] rev=reverse(pre.next,head);//每k个一组进行反转
                    pre.next=rev[0];
                    rev[1].next=next;
                    head=next;
                    pre=rev[1];                                         
            }     
        }
         return hair.next;
    }
   public ListNode[] reverse (ListNode left,ListNode right){
       
       
       ListNode pre=null;
       ListNode tail=left;
       ListNode temp=left;
       while(temp!=right){
           
           ListNode next=temp.next;
           temp.next=pre;
           pre=temp;
           temp=next;
           
       }
       temp.next=pre;
       
       return new ListNode[]{temp, tail};
           
          
   }
```

#### [5.链表环中的入口结点](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

对于一个给定的链表，返回环的入口节点，如果没有环，返回null

拓展：

你能给出不利用额外空间的解法么？

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\环形链表.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\环形链表.png)

fast=a+b+c+b;

slow=a+b；

fast=slow*2;------>a=c   

```java
 public ListNode detectCycle(ListNode head) {
        
        if(head==null || head.next==null) return null;
        
        ListNode slow=head;
        ListNode fast=head;
        
        while(fast!=null && fast.next!=null){
            
            slow=slow.next;
            fast=fast.next.next;
            if(fast==slow){
                fast=head;
                while(fast!=slow){
                    
                    fast=fast.next;
                    slow=slow.next;
                }
                
                return slow;
            }      
            
        }
        
        return null;
        
        
        
    }
```

#### [6.删除链表的倒数第n个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```java
//时间复杂度O(N)
//空间复杂度O(1)
public ListNode removeNthFromEnd (ListNode head, int n) {
        // write code here
        ListNode fast=head;
        ListNode slow=head;
        int i=0;
        while(i<n){//先让快指针往前走n步
            
            fast=fast.next;
            i++;
        }
        if(fast==null) return head.next;
        while(fast.next!=null){
            
            fast=fast.next;
            slow=slow.next;
        }
        slow.next=slow.next.next;
        return head;
        
    }
```

#### [7.两个链表的第一个公共节点](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

```java
//将第一个链表的尾部和第二个链表的头部连起来，用一个指针遍历，将第二个链表的尾部和第一个链表的头部连起来，用另一个指针遍历，两个指针相遇，就是公共节点。
//时间复杂度O(M+N) 空间复杂度O(1) 
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        
        
        ListNode head1=pHead1;
        ListNode head2=pHead2;
        
        while(head1!=head2){
            
            if(head1==null) head1=pHead2;//为什么head1.next==null会报错
            else head1=head1.next;
            if(head2==null) head2=pHead1;
            else head2=head2.next;
            
            
        }
        
        return head1;
        
    }
```

#### [8.两个链表生成相加链表](https://leetcode-cn.com/problems/sum-lists-lcci/)

假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。

给定两个这种链表，请生成代表两个整数相加值的结果链表。

例如：链表 1 为 9->3->7，链表 2 为 6->3，最后生成新的结果链表为 1->0->0->0。

```java
//思路：将两个链表反转之后相加
//时间复杂度：反转链表O(M+N)+链表相加O(Max{M,n})
public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        
        ListNode node1=reverse(head1);//反转链表
        ListNode node2=reverse(head2);//反转链表
        ListNode head=new ListNode(0);
        ListNode pre=head;
        int carry=0;
    //链表相加
        while(node1!=null || node2!=null || carry!=0){
            
            int i=0;
            int j=0;
            if(node1!=null){           
                 i=node1.val;
                node1=node1.next;
            }
            if(node2!=null){       
              
                j=node2.val;
                node2=node2.next;
            }
            int sum=i+j+carry;
            carry=sum/10;
            ListNode node=new ListNode(sum%10);
            head.next=node;
            head=node;
            
            
        }
        
        return reverse(pre.next);//反转相加后的链表
           
    }
   //反转链表 
    public ListNode reverse(ListNode head){
        
        ListNode pre=null;
        ListNode node =head;
        while(node!=null){
            
            ListNode next=node.next;
            node.next=pre;
            pre=node;
            node=next;
        
        }
        return pre;
    }
```

#### [8.合并k个已经排序的链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/)

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\合并k个已经排序的链表.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\合并k个已经排序的链表.png)

```java
//时间复杂度计算:设有k组，链表最大长度为n
//第一轮合并k/2组链表，每一组的代价为O(2n)，第二轮合并k/4组链表。每一组代价为O(4n)....
//一共有logk轮，则复杂度为O(kn*logK)
//递归会使用到O(logk)空间代价
public ListNode mergeKLists(ArrayList<ListNode> lists) {
        
       return  merge(lists,0, lists.size()-1);
        
    }
    
    public ListNode merge(ArrayList<ListNode> lists,int l,int r){
        
        if(l==r) return lists.get(l);
        if(l>r ) return null;
        
        int mid=(l+r)/2;
        
        return mergeTwoList(merge(lists,l,mid),merge(lists,mid+1,r));//递归
    }
    //合并两个链表
    public ListNode mergeTwoList(ListNode l1,ListNode l2){
        
        ListNode pre=new ListNode(0);
        ListNode head=pre;
        
        while(l1!=null && l2!=null){
            
            if(l1.val<l2.val){
                
                pre.next=l1;
                l1=l1.next;
                
            }
            else{
                
                pre.next=l2;
                l2=l2.next;
            }
            pre=pre.next;
        }
        
       if(l1!=null) pre.next=l1;
       if(l2!=null) pre.next=l2;
        return head.next;
    }
```

#### [9. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\排序链表.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\排序链表.png)

```java
//时间复杂度O(nlogn)
//空间复杂度O(1)
public ListNode sortList(ListNode head) {

        ListNode pre=new ListNode(0);
        pre.next=head;
        ListNode hair=pre;
        int len=0;//先计算链表的长度
        while(head!=null){

            len++;
            head=head.next;
        }

        for(int curlen=1;curlen<len;curlen<<=1){//每次合并长度为之前的二倍
            ListNode curpre=pre;
            ListNode curhead=pre.next;
            while(curhead!=null){//遍历链表并合并
               
                ListNode head1=curhead;
                for(int i=1;i<curlen && curhead!=null;i++){
                      
                      curhead=curhead.next;
                }
                ListNode tail1=curhead;

                if(curhead!=null){
                    curhead=curhead.next;
                    tail1.next=null;
                }
                 ListNode head2=curhead;
                for(int i=1;i<curlen && curhead!=null;i++){

                    curhead=curhead.next;
                }
                ListNode tail2=curhead;
                if(curhead!=null) 
                {
                    curhead=curhead.next;
                    tail2.next=null;
                }
                ListNode mergehead=merge(head1,head2);
                curpre.next=mergehead;
                while(curpre.next!=null){

                    curpre=curpre.next;
                }
                
                curpre.next=curhead; 
               
            }
        
        }

        return pre.next;
    }
//合并两个有序链表
    public ListNode merge(ListNode head1,ListNode head2){

        ListNode pre=new ListNode(0);
        ListNode head=pre;
        while(head1!=null && head2!=null){

            if(head1.val>head2.val){

              head.next=head2;
              head2=head2.next;

            }else{

                head.next=head1;
                head1=head1.next;
                
            }
            head=head.next;
        }

        if(head1!=null) head.next=head1;
        if(head2!=null) head.next=head2;
        return pre.next;
    }
```

#### [10.回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/)

编写一个函数，检查输入的链表是否是回文的。

```java
//使用快慢指针找到中点(奇数和偶数处理情况不一样)
//反转后面的链表
//判断两个链表是否相同
//时间复杂度O(N) 空间复杂度O(1)
public boolean isPalindrome(ListNode head) {

     if(head==null) return true;
     ListNode slow=head;
     ListNode fast=head;
     ListNode pre=head;
     while(fast!=null && fast.next!=null){

         pre=slow;
         slow=slow.next;
         fast=fast.next.next;
     }

     pre.next=null;

     if(fast!=null)//说明是奇数个,中间的数据要舍弃掉
     {
         slow=slow.next;
     }
     ListNode head2=reverse(slow);
     while(head!=null && head2!=null){

         if(head.val!=head2.val) return false;
         head=head.next;
         head2=head2.next;
     }

     return true;

    }

//反转链表

    public ListNode reverse(ListNode head){

        if(head==null) return null;
        ListNode pre=null;
        //head.next=pre;

        while(head.next!=null){

            ListNode next=head.next;
            head.next=pre;
            pre=head;
            head=next;
        }
        head.next=pre;

        return head;
    }
```

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\复制复杂的链表.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\复制复杂的链表.png)

```java
/*方法一：
使用hashmap存储原链表的node和复制的node
之后通过递归的方式重建链表
时间复杂度O(N)
空间复杂度O(N)
*/
	HashMap<Node,Node> map = new HashMap<>();//前一个node是原链表的node,后面那个node是复制的
    public Node copyRandomList(Node head) {

        if(head == null)  return head;

        if(map.containsKey(head)){//如果node已经有了，直接返回就行

            return map.get(head);
        }
        

        Node node = new Node(head.val,null,null);//如果head的复制节点没有，就创建并放入map中
        map.put(head,node);

        node.next = copyRandomList(head.next);//创建或者获取node的next节点
        node.random = copyRandomList(head.random);//创建或者获取node的random节点

        return node;
        
    }

//方法2：首先先拼接链表，也就是原链表的每个节点的next为他的复制的节点
//遍历拼接后的链表，根据原链表的random来获取复制节点的random
//拆分链表
//时间复杂度O(N)空间复杂度O(1)
 public Node copyRandomList(Node head) {
      
       if(head == null)  return head;
       Node cur = head;
       while(cur != null){//拼接链表

           Node node = new Node(cur.val,null,null);
           node.next = cur.next;
           cur.next = node;
           cur = node.next;
       }

       cur = head;
       while(cur != null){//获取复制节点的random

           if(cur.random != null){

               cur.next.random = cur.random.next;
           }

           cur = cur.next.next;
       }

       cur = head;
       Node temp = head.next;
       Node res = temp;
       while(temp.next != null){//拆分链表

           cur.next = cur.next.next;
           temp.next = temp.next.next;
           cur = cur.next;
           temp = temp.next;

       }

       cur.next = null;
       return res;   
    }
```

#### [1.排序数组(912)](https://leetcode-cn.com/problems/sort-an-array/)

##### 归并排序

- 基本思想：对于一个长度为$N$的待排数组，可以将其分为两个$n/2$的子序列，每次通过递归调用函数使字序列有序，然后再线性合并两个子序列。
- 时间复杂度：$O(N$$log_2$$N)$ 
- 空间复杂度：$O(N)$
- 稳定的排序

``` java
    public static void margeSort(int[]nums,int l,int r){

        if(l>=r)  return;

        int mid=(l+r)/2;
        margeSort(nums, l, mid);
        margeSort(nums, mid+1, r);

        int i=l;
        int j=mid+1;
        int  k=0;
        //合并两个有序数组
        while(i<=mid && j<=r){

            if(nums[i]>=nums[j])
                temp[k++]=nums[j++];
            else 
                temp[k++]=nums[i++]; 

        }

        while(i<=mid){

            temp[k++]=nums[i++];
        }
        while(j<=r){
            temp[k++]=nums[j++];
        }

        for(int p=l;p<=r;p++){

            nums[p]=temp[p-l];
        }

    }

```

##### 快速排序

- 时间复杂度：$O(N$$log_2$$N)$ 最坏:$O(n^2)$
- 空间复杂度：最好：$O($$log_2$$N)$ 最坏：$O(N)$
- 不稳定
- 待排数组 6 9 9我们选择第二个9作为主元，若把小于放在主元的左边，最后第二个9就跑到第一个9左面了，从而导致不稳定，主元的选择是随机的，导致不稳定的原因在于我们无法保证每次都是稳定的，所以它是不稳定的。
- 最好的情况: 每次选的pivot几乎能把数据均分成两半，这样递归树的深度就是`logN`，这样快排的时间复杂度为`O(NlogN)`
- 最坏的情况：每次找的pivot将数组分成两部分，其中有一部分是空。一般当数据有序或者局部有序的时候会出现这种坏的情况，比如数组正序或者逆序.

```java
public void QuickSort(int []arr,int l,int r){
        
        if(l>=r) return;   
        int pos=partition(arr,l,r);
        QuickSort(arr,l,pos-1);
        QuickSort(arr,pos+1,r);
        
}
//划分数据为2部分，一部分数据大于pos的数据，另一半小于pos的数据

public int partition(int[]arr,int l,int r){
        
        int i=l + new Random.nextInt(r - l + 1);
        swap(arr,i,r);
        for(int j=l;j<r;j++){
              
            if(arr[j]<arr[i]){
                i++;
                swap(arr,i,j);
            }
        }
        i=i+1;
        swap(arr,i,r);
        
        return i;
}
    
public void swap(int[]nums,int i,int j){
        
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;

    }

```

##### 堆排序

- 堆分为大根堆和小根堆。在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。
- 堆排序的思想就是先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。
- 不稳定：如3 27 36 27
- 时间复杂度：$O(NlogN)$
- 空间复杂度：$O(1)$

```java
 public void HeapSort(int[] arr){
        
        int len=arr.length-1;
        buildMaxHeap(arr,len);//先建一个大根堆
        for(int i=len;i>0;i--){//每次把最大的元素放在后面
            
            swap(arr,0,i);
            len--;
            maxHeap(arr,0,len);
        } 
    }
    //
    public void buildMaxHeap(int []arr,int len){
        
        for(int i=len/2;i>=0;i--){ //因为最后一层的元素没有孩子，所以就不用管
            maxHeap(arr,i,len);
        }
    }
    
    //以某个节点为根节点建造大根堆
    public void maxHeap(int []arr,int i,int len){
        
        while((i<<1)+1<=len){
            
            int left=(i<<1)+1; //完全二叉树左节点为2*i+1
            int right=(i<<1)+2;//完全二叉树右节点为2*i+2
            int max;
            if(arr[i]<arr[left]){
                
                max=left;
            }else{
                
                max=i;
            }
            if(right<=len && arr[right]>arr[max]){
                max=right;      
            }
            if(i!= max)//这时候做了调整，
            {
                swap(arr,i,max);
                i = max;
                    //因为左节点或者右节点变了，所以左节点/右节点的孩子也要变
               
             }
            else  break;//没有做调整，直接跳出就行
            
            
        }  
        
    }
    	public void swap(int []nums,int i,int j){
	    int temp=nums[i];
	    nums[i]=nums[j];
	    nums[j]=temp;
	    
	   }

```

##### 冒泡排序

- 基本思想：对于每一趟，比较相邻的元素，如果前一个比后一个大，就交换，每一趟都是把最大的一个移到最后一个。
- 因此需要n-1趟。
- 时间复杂度：

``` java
private static void bubbleSort(int[] arr) {
        if(arr==null || arr.length < 2 ){
            return;
        }
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - i -1; j++) {   // 这里说明为什么需要-1
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
```

#### [2. 最小的K个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/zui-xiao-de-kge-shu-by-leetcode-solution/)

给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K>数组的长度，那么返回一个空的数组.

```java
public int[] getLeastNumbers(int[] arr, int k) {

        QuickSort(arr,0,arr.length-1,k);
        int []res = new int[k];
        for(int i = 0;i < k; i++){

            res[i] = arr[i];
        }

        return res;

    }

    public void QuickSort(int []arr,int l,int r,int k){
       
        if(l >= r) return;
        int pos = partition(arr,l,r);
        int num = pos - l + 1;//计算出前多少个是有序的
          //在这里与快排不同
        if(num == k)  return;//如果pos右边的个数等于k,说明已经得到了
        else if(num < k){//如果pos右边的个数小于k,说明还要在左边找k-num个数
            
            QuickSort(arr,pos+1,r,k-num);

        }else{//如果pos右边的个数大k,说明还要在右边继续找k个数

            QuickSort(arr,l,pos-1,k);
        }

    }

    public int partition(int []arr,int l,int r){
   
        int pivot = l + new Random().nextInt(r - l + 1);
        swap(arr,pivot,r);
        int i = l - 1;
        for(int j = l;j < r;j++){

            if(arr[j] <= arr[r]){

                i++;
                swap(arr,i,j);
            }
        }
        i = i + 1;
        swap(arr,i,r);
        return i;
    }

    public void swap(int []nums,int i,int j){

        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
```

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个.

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\数组排序.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\数组排序.png)

可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 > S2+S1，那么应该把 S2 排在前面，否则应该把 S1 排在前面。

```java
public String minNumber(int[] nums) {

        
        if (nums == null || nums.length == 0)
        return "";
        int n = nums.length;
        String[] number = new String[n];
        for (int i = 0; i < n; i++)
            number[i] = nums[i] + "";
        Arrays.sort(number, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
        String ret = "";
        for (String str : number)
            ret += str;
        return ret;


    }
```

#### [1. 二叉树的前序，中序，后序遍历](https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=196&tqId=37153&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)

分别按照二叉树先序，中序和后序打印所有的节点。

递归法  https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/

```java
//时间复杂度:O(N)
//空间复杂度;O(N)

public List<Integer> prelist;
    public List<Integer> midlist;
    public List<Integer> postlist;
    public int[][] threeOrders (TreeNode root) {
        // write code here
        prelist=new ArrayList<>();
        midlist=new ArrayList<>();
        postlist=new ArrayList<>();
         
        perorder(root);
        midorder(root);
        postorder(root);
        int [][]res=new int[3][prelist.size()];
       
         for(int i=0;i<prelist.size();i++){
             res[0][i]=prelist.get(i);
         }
         for(int i=0;i<prelist.size();i++){
             res[1][i]=midlist.get(i);
         }
         for(int i=0;i<prelist.size();i++){
             res[2][i]=postlist.get(i);
         }
        
        return res;
    }
    //前序遍历
    public void perorder(TreeNode root){
        
        if(root==null) return;
        
        prelist.add(root.val);
        perorder(root.left);
        perorder(root.right);
       
    }
    //中序遍历
    public void midorder(TreeNode root){
        
        if(root==null)  return;
        midorder(root.left);
        midlist.add(root.val);
        midorder(root.right);
         
        
    }
    //后序遍历
    public void postorder(TreeNode root){
        
        if(root==null) return;
        postorder(root.left);
        postorder(root.right);
        postlist.add(root.val);
          
    }
  
```

非递归法

```java
//前序遍历
//时间复杂度O(N)
//空间复杂度O(lgn)
public List<Integer> preorderTraversal(TreeNode root) {


        List<Integer> res = new ArrayList<Integer>();
        Stack<TreeNode> st = new Stack<TreeNode>();
        st.push(root);
        while(!st.isEmpty()){

            TreeNode node = st.pop();
            if(node == null)  continue;//先判断一下是不是空，因此我们每次加进去的有可能是空节点
            res.add(node.val);
            st.push(node.right);//由于是栈，所以先把右节点放进去
            st.push(node.left);
        }

        return res;
        
    }

//后序遍历
//时间复杂度O(N)
//空间复杂度O(lgn)
public List<Integer> preorderTraversal(TreeNode root) {


        List<Integer> res = new ArrayList<Integer>();
        Stack<TreeNode> st = new Stack<TreeNode>();
        st.push(root);
        while(!st.isEmpty()){

            TreeNode node = st.pop();
            if(node == null)  continue;//先判断一下是不是空，因此我们每次加进去的有可能是空节点
            res.add(node.val);
            st.push(node.left);//由于是栈，所以先把左节点放进去
            st.push(node.right);
        }
        Collections.reverse(res);  //根右左---->左右根
        return  res;
        
    }


//中序遍历
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    if (root == null) return ret;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {//把左节点加入栈中
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();//每弹出一个节点
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}
```

#### [2. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/)

给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）

```java
public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
         // write code here
       
        
        ArrayList<ArrayList<Integer>> res=new ArrayList<ArrayList<Integer>>();
        if (root==null) return res;
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        q.add(root);
        
        while(!q.isEmpty()){
            
            int size=q.size();
            ArrayList<Integer> temp=new ArrayList<>();
            for(int i=0;i<size;i++){
                
                TreeNode node=q.poll();
                temp.add(node.val);
                if(node.left!=null)  q.add(node.left);
                if(node.right!=null) q.add(node.right);
               
            }
            
            res.add(temp);
        }
        return res;
       
    }
```

#### [3.二叉树的之字型层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）

```java
//时间复杂度O(N) 空间复杂度O(N)
public ArrayList<ArrayList<Integer>> zigzagLevelOrder (TreeNode root) {
        // write code here
        
        ArrayList<ArrayList<Integer>> res=new ArrayList<ArrayList<Integer>>();
        if(root==null) return res;
        Stack <TreeNode> st1 =new Stack<TreeNode>();//奇数层用一个栈
        Stack <TreeNode> st2 =new Stack<TreeNode>();//偶数层再用一个栈
        
        st1.push(root);
       
        
        while(!st1.isEmpty() || !st2.isEmpty()){
            
            if(!st1.isEmpty()){
                int st1Size=st1.size();

                ArrayList<Integer> temp=new ArrayList<Integer>();

                for(int i=0;i<st1Size;i++){

                    TreeNode node=st1.pop();
                    temp.add(node.val);
                    if(node.left!=null) st2.push(node.left);//
                    if(node.right!=null)st2.push(node.right);

                }
      
                 res.add(temp);
            }
        
         if(!st2.isEmpty()){
            int st2Size=st2.size();
            ArrayList<Integer> temp=new ArrayList<Integer>();
            for(int i=0;i<st2Size;i++){
                
                TreeNode node=st2.pop();
                temp.add(node.val);
                if(node.right!=null) st1.push(node.right);//倒一下
                if(node.left!=null)st1.push(node.left);
                
            }
           res.add(temp);
            
        }
      }
        
        return res;
    }
```

#### [4.二叉树的两个节点最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/)

给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。

```java
//时间复杂度O(N) 
//空间复杂度O(N) 最坏的情况下为一条链，此时高度为O(N)
public int ans;
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        dfs(root,o1,o2);
        return ans;
        
    }
    
    public boolean dfs(TreeNode root,int o1,int o2){
        
        if(root==null) return false;
        
        boolean bleft=dfs(root.left,o1,o2);//看一下左子树上有没有
        boolean bright=dfs(root.right,o1,o2);//看一下右子树上有没有
        
        if((bleft && bright)||(root.val==o1 || root.val==o2) && (bleft|| bright) ){//如果左右子树都有，或者一个在根，一个在左/右，就算找到了
            
            ans=root.val;
        }
        
        return( bleft || bright || root.val==o1 || root.val==o2);//找到了就返回true
        
        
    }
```

#### [5.重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
//时间复杂度O(N)
//空间复杂度O(N)

public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        
        if(pre.length==0) return null;
        
        TreeNode root=new TreeNode(pre[0]);//获取根节点
        
        for(int i=0;i<in.length;i++){
            
            if(in[i]==pre[0]){//构造左右子树
                
            root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i));
            root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,in.length),Arrays.copyOfRange(in,i+1,in.length));
                
                break;
            }
        }
        
        return root;
            
        
    }
```

#### [6.输入二叉树的右视图](https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=196&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图

```java
//先构造二叉树 时间复杂度O(N) 空间复杂度O(N)
//再层序遍历 时间复杂度O(N)  空间复杂度O(N)
public int[] solve (int[] xianxu, int[] zhongxu) {
        // write code here
        
        TreeNode root=getTree(xianxu,zhongxu);
        
        ArrayList<Integer> list=new ArrayList<Integer>();
        Queue <TreeNode>q= new LinkedList<TreeNode>();
        
         q.add(root);
        while(!q.isEmpty()){
            
            int size=q.size();
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                if(i==size-1) list.add(node.val);
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
                
            }
        }
        
        int []res=new int[list.size()];
        for(int i=0;i<list.size();i++){
            res[i]=list.get(i);
            
        }
        
        return res;        
        
        
    }
    
    public TreeNode getTree(int [] pre,int []in){
        
        if(pre.length==0)  return null;
        
        TreeNode root =new TreeNode(pre[0]);
        
        for(int i=0;i<in.length;i++){
            
            if(in[i]==pre[0]){
                
                root.left=getTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i));
                root.right=getTree(Arrays.copyOfRange(pre,i+1,in.length),Arrays.copyOfRange(in,i+1,in.length));
                break;
            }
        }
        return root;
    }
    
```

#### [7.二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

```java
//深度优先 
//以root为根的最大深度，为左子树和右子树中最大的深度加1
//时间复杂度O(N)
//空间复杂度O(h)为树的高度
public int maxDepth(TreeNode root) {

        if(root==null) return 0;

        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;

    }

//也可以用广度优先层序遍历
```

#### [8.平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

 

```java
//时间复杂度O(N)
//空间复杂度O(N)
//终止条件：当root为空时，返回高度为0  当左右子树深度为-1，也就是不是平衡二叉树，就返回-1
//返回值：当前节点左右子树深度差小于等于1,就返回当前左右子树深度最大值加1,否则说明不是平衡二叉树，就返回-1

public boolean isBalanced(TreeNode root) {

         return dfs(root)!=-1;

    
    }
    public int dfs(TreeNode root){

        if(root==null) return 0;
        int left=dfs(root.left);
        if(left==-1) return -1;
        int right=dfs(root.right);
        if(right==-1) return -1;

        return Math.abs(right-left)<=1 ? Math.max(left,right)+1:-1;
        


    }
```

#### [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

```java
// 时间复杂度O(N) 遍历每个节点
// 空间复杂度O(N)
public int widthOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        int res = 1;
        LinkedList<TreeNode> queue = new LinkedList<>();
        LinkedList<Integer> indexQueue = new LinkedList<>();
        queue.add(root);
        indexQueue.add(1);
        while (!queue.isEmpty()) {
            int left = indexQueue.peek();
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                TreeNode poll = queue.poll();//当前节点
                Integer index = indexQueue.poll();//当前该节点的索引值
                res = Math.max(res, index - left + 1);//计算当前节点与最左节点的距离
                if (poll.left != null) {
                    queue.add(poll.left);
                    indexQueue.add(index * 2);//左节点的索引值为父节点位置*2
                }
                if (poll.right != null) {
                    queue.add(poll.right);
                    indexQueue.add(index * 2 + 1);//右节点的索引值为父节点位置*2+1
                }
            }
        }
        return res;
    }
```

#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

请实现两个函数，分别用来序列化和反序列化二叉树。

```java
//时间：O(N) 空间O(N)
public class Codec {

    // Encodes a tree to a single string.
    //使用层序遍历将元素加入string中
    public String serialize(TreeNode root) {

        Queue <TreeNode> q = new LinkedList<>();
        q.add(root);
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while(!q.isEmpty()){

            int size = q.size();
            boolean bnull = true;
            for(int i = 0 ; i < size; i++){

                TreeNode node = q.poll();
                
                if(node != null){//如果不为null，就直接加入元素

                    sb.append(node.val + ",");
                    q.add(node.left);
                    q.add(node.right);
                
                }else{//如果为null，

                    sb.append("null,");
                }
            }

        }
        sb.replace(sb.length()-1, sb.length(),"]");

        return new String(sb);
        
    }

    // Decodes your encoded data to tree.
    
    //反序列化
    public TreeNode deserialize(String data) {

        if(data.equals("[null]")) return null;

        String[] s = data.substring(1,data.length()-1).split(",");
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        TreeNode root = new TreeNode(Integer.parseInt(s[0]));
        q.add(root);
        int i = 1;
        while(!q.isEmpty()){

             TreeNode node = q.poll();
             if(!s[i].equals("null")){

                 node.left = new TreeNode(Integer.parseInt(s[i]));
                 q.add(node.left);      
             }
            i++;
             if(!s[i].equals("null")){

                 node.right = new TreeNode(Integer.parseInt(s[i]));
                 q.add(node.right);      
            }
            i++;
                  
        }

        return root;

            
    }
}
```

#### [1. 分割整数](https://leetcode-cn.com/problems/integer-break/)

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```java
//时间复杂度O(N)
//空间复杂度O(1)
public int integerBreak(int n) {

        if(n<=3)  return n-1;

        int res=1;
        while(n > 4){

            res=res*3;
            n=n-3;
        }

        return res*n;

    }
```

#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

```java
 public int lastRemaining(int n, int m) {
    //f(n)表示0~n-1的数字删除第m元素后留下的数字 t=m%n  表示删除第t个元素，0,1,2,3...t-1,t,t+1，..n-1
    //也就是删除t-1后变成 t,t+1,t+2,.....0,1,2,t-3,t-2 一共n-1个数
    //对于f(n-1)  0,1,2,3.....n-2 删除后留下的数据为x,那么对于上一个序列而言，删除后留下的数据就是与x在0:n-2这个序列中的相同位置的数据
    //[n-1,m]问题             [n,m]删除t后的问题
    //   0                         t
    //   1                         t+1
    //   2                         t+2
    //   ..                          ..
    //  n-3                         t-3
    //  n-2                         t-2    
//如果[n-1,m]问题的解为x，则[n,m]问题的解为(x+t)%n
//f(n)=(x+t)%n = (f(n-1)+t)%n =  (f(n-1)+m%n)%n  =  (f(n-1)+m)%n              


        int x = 0;

        for(int i = 2;i <= n; i++){

            x = (x + m) % i;//注意这个位置是i
        }
        return x;              
    }       
```

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

| 数字范围  | 位数  | 数字数量 | 数位数量          |
| --------- | ----- | -------- | ----------------- |
| 1~9       | 1     | 9        | 9                 |
| 10~99     | 2     | 90       | 90*2              |
| 10~99     | 3     | 900      | 900*3             |
| .....     |       |          |                   |
| start~end | digit | 9*start  | 9* start  * digit |

```java
/*
时间复杂度：O(logn)   while循环：设循环的i次，则count=i*10^i*9,n=n-i*10^i*9,也就是当count = n时。i*10^i=n --->i=logn
遍历num，这时候digit=i=logn，所以遍历也需要logn的时常
空间复杂度：：O(logn) 用于存放最后num的string
*/
public int findNthDigit(int n) {

        long start = 1;
        long count = 9;
        int digit = 1;

        while(count < n){//
            n -= count;//每次减去之前计数的位数
            start *= 10;
            digit += 1;
            count = start * digit * 9;
        }

        long num = start + (n - 1)/ digit;//找到那个数字
        return Long.toString(num).charAt((n - 1) % digit) - '0';//(n-1)%digit为在数字中所处的位数

    }
```

#### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

```java
//设数字n是x位数，n=nxnx-1.....n2n1;
//cur : 当前数：ni
//high:高位数，nxnx-1....ni+1
//low:低位数：ni-1.....n1;
//digit 10^i
//当cur = 0时：如23042   中的第三位，固定第三位为1,这时候取值范围为00100~22199,可以看作0000-2299：一共有2300种情况，即 high*digit
//当cur = 1时：如23142   中的第三位，固定第三位为1,这时候取值范围为00100~23142,可以看作0000-2342：一共有2343种情况，即 high*digit+low+1;
//当cur为其他情况时：如23443 中第三位，固定第三位为1，这时候取值范围为00100~23199,可以看作0000-2399:一共2400种情况，即(high+1)*digit;
//时间复杂度O(log10n) 循环次数为n的位数
//空间复杂度O(1)
public int countDigitOne(int n) {

        int digit = 1;
        int high = n /10;
        int cur = n % 10;
        int low = 0;
        int sum = 0;
        while(high != 0 || cur != 0){

            if(cur == 0)  sum +=high * digit;
            else if(cur == 1) sum = sum + high * digit + low + 1;
            else  sum += (high+1)*digit;
            low += cur * digit;
            cur = high % 10;
            high = high / 10;
            digit *=10;
        }

        return sum;

    }
```

#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。、

```java
/*时间复杂度：
查找中位数 O(1) ： 获取堆顶元素使用 O(1) 时间；
添加数字O(logN) ： 堆的插入和弹出操作使用 O(logN) 时间。
空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。*/


class MedianFinder {

    /** initialize your data structure here. */
    
    PriorityQueue<Integer> q_min,q_max;

    public MedianFinder() {

        q_min = new PriorityQueue<>();  //小顶堆，也就是我们需要获取最小值的那一半，也就是后半部分的序列
        q_max = new PriorityQueue<>((x,y)->(y-x));//大顶堆，也就是需要获取最大值的那一半，也就是前半部分

    }
    
    public void addNum(int num) {

        //1. 我们需要保证后半部分的个数等于前半部分的个数(偶数时)，或者等于前半部分的个数+1(奇数时)
        //2. 还要保证小顶堆的最小值大于大顶堆的最大值。
        //添加一个元素时，有两种情况
        //如果两个堆元素个数相同，要保证第一个条件，就需要向小顶堆中添加元素，但是如果直接添加有可能添加的那个元素的值会小于大顶堆的最大值，所以需要流程是：向大顶堆中添加元素，然后把大顶堆的最大值拿给小顶堆。
        //如果两个堆元素个数不同，要保证第一个条件，就需要向大顶堆中添加元素，但是如果直接添加有可能添加的那个元素的值会大于小顶堆的最小值，所以需要流程是：向小顶堆中添加元素，然后把小顶堆的最小值拿给大顶堆。
        if(q_min.size() != q_max.size()){

            q_min.add(num);
            q_max.add(q_min.poll());
        }else{

             q_max.add(num);
             q_min.add(q_max.poll());
        }

    }
    
    public double findMedian() {

        //如果两个堆元素个数相同，则返回两个堆最大最小的平均数
        //如果两个堆元素个数不同，则返回最小堆的最小值
        return q_max.size() == q_min.size() ? 1.0*(q_max.peek()+q_min.peek())/2 : 1.0*q_min.peek();

    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

#### [1.合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给出两个有序的整数数组 ![img](https://www.nowcoder.com/equation?tex=A%20%5C)和 ![img](https://www.nowcoder.com/equation?tex=B%5C)，请将数组 ![img](https://www.nowcoder.com/equation?tex=B%5C)合并到数组 ![img](https://www.nowcoder.com/equation?tex=A%5C)中，变成一个有序的数组
注意：
可以假设 ![img](https://www.nowcoder.com/equation?tex=A%5C)数组有足够的空间存放 ![img](https://www.nowcoder.com/equation?tex=B%5C)数组的元素， ![img](https://www.nowcoder.com/equation?tex=A%5C)和 ![img](https://www.nowcoder.com/equation?tex=B%5C)中初始的元素数目分别为 ![img](https://www.nowcoder.com/equation?tex=m%5C)和 ![img](https://www.nowcoder.com/equation?tex=n%5C)

```java
//时间复杂度：O(m+n)
//空间复杂度O(1)
双指针，从后往前进行判断
public void merge(int A[], int m, int B[], int n) {
        int i=m-1,j=n-1;
        int k=m+n-1;
        while(i>=0 && j>=0){
            
            if(A[i]<=B[j]){
                
                A[k--]=B[j--];
            }
            else{
                
                A[k--]=A[i--];
            }
            
            
        }
        
        while(i>=0){
            
            A[k--]=A[i--];
        }
        while(j>=0){
            A[k--]=B[j--];
        }
        
       
        
    }
```

#### [2.螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。

输入：[[1,2,3],[4,5,6],[7,8,9]]

输出：[1,2,3,6,9,8,7,4,5]

```java
 public ArrayList<Integer> spiralOrder(int[][] matrix) {
        ArrayList<Integer> res=new ArrayList<Integer>();
        int row=matrix.length;
        if(row==0) return res;
        int col=matrix[0].length;
        
        int left=0;
        int right=col-1;
        int top=0;
        int bottom=row-1;        
        while(true){
            
            if(left>right) return res;       
            for(int i=left;i<=right;i++){
                
                res.add(matrix[top][i]);
            }
            top++;
            
            if(top>bottom) return res;
            
            for(int i=top;i<=bottom;i++){
                
                res.add(matrix[i][right]);
            }
            
            right--;
            if(left>right) return res;
            for(int i=right;i>=left;i--){
                
                res.add(matrix[bottom][i]);
            }
            bottom--;
            if(top>bottom) return res;
            for(int i=bottom;i>=top;i--){
                
                res.add(matrix[i][left]);
            }
            left++;
            
             
        }
   
    }
```

#### [3.数组中相加和为0的三元组](https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=196&tqId=37085&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)

给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。

注意：

1. 三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）
2. 解集中不能包含重复的三元组。

```java
 //先排序
//遍历数组中的每个元素并固定该元素num[i]
//计算num[i+1]到num[len-1]中两个数据相加为-num[i]的数据
//一些特殊情况 当num[i]>0时说明查找结束，因为后面的数据都大于0
//去重：num[i]=num[i-1]时，就不用再查找了   
//时间复杂度O(nlogn)+O(n)
public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
       ArrayList<ArrayList<Integer>> res=new ArrayList<ArrayList<Integer>>();
       Arrays.sort(num);
      
       for(int i=0;i<num.length;i++){
           
           if(num[i]>0){//当num[i]>0时说明查找结束，因为后面的数据都大于0
               
               break;
           }
           
           if(i-1>=0 && num[i]==num[i-1]){//num[i]=num[i-1]时，就不用再查找了  
               
               continue;
           }
           
           int left=i+1;
           int right=num.length-1;
           
           while(left<right){
               
               int sum=num[left]+num[right]+num[i];
               if(sum==0)
               {
                   ArrayList<Integer> temp=new ArrayList<Integer>();
                   temp.add(num[i]);
                   temp.add(num[left]);
                   temp.add(num[right]);
                   res.add(temp);  
                   while(left<right && num[left]==num[left+1]){//去重
                        left++;
                   }
                  while(left<right && num[right]==num[right-1]){//去重
                       right--;
                  }
                   left++;
                   right--;
                  
                   
               }else if(sum<0){
                   
                   left++;
               }else{
                   
                   right--;
               }
              
           }
       }
        
       
        return res;
        
    }
```



#### [4.买股票的最好时机](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/gu-piao-de-zui-da-li-run-by-leetcode-sol-0l1g/)

假设你有一个数组，其中第 *i* 个元素是股票在第i天的价格。
你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益

输入:[1,4,2]  输入：3

```java
   public int maxProfit (int[] prices) {
        // write code here
        int max=prices[prices.length-1];//记录未来最大的价格
        int res=0;//最大的利润
        
        for(int i=prices.length-2;i>=0;i--){
            
            res=Math.max(res,max-prices[i]);
            max=Math.max(max,prices[i]);
            
        }
        
        return res;
    }
```

#### [5.数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字.

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```java
 //使用哈希存储num中每个数据出现的次数,最后返回次数最大的那一个数据
//时间复杂度O(N)
//空间复杂度O(N)
public int majorityElement(int[] nums) {

        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int count=0;
        int maxcount=0;
        int res=0;
        
        for(int num:nums){
             
             if(!map.containsKey(num)) map.put(num,1);
             else {

                 map.put(num,map.get(num)+1);
             }

        }

        for(int key:map.keySet()){
          
          if(map.get(key)>maxcount)
          {
               maxcount=map.get(key); 
               res=key;
          }
            
        }
        return res;

    }

//投票法:时间复杂度O(N),空间复杂度O(1)
//初始化:票统计数vote=0,众数res=0
//循环:遍历数组中每个数字num
   //1。当票数vote=0.则假设当前数组num是众数
   //2.当num=res时，vote=vote+1，否则vote=vote-1;
public int majorityElement(int[] nums) {
        
        int vote=0;
        int res=0;

        for(int num:nums){

            if(vote==0) res=num;
            if(num==res) vote=vote+1;
            else vote=vote-1;
            

        }
        return res;

    }
```

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\摩尔投票法.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\摩尔投票法.png)

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\摩尔投票法2.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\摩尔投票法2.png)

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```java
//设dp[i]为以nums[i]为结尾的和的最大的值
//dp[i-1]<=0 说明前面的数据没有贡献或者为负贡献，直接设dp[i]=nums[i]然后相加
//dp[i-1] > 0 dp[i]=dp[i-1]+nums[i]
//可以用nums[i]代表dp[i]
//时间复杂度O(N)
//空间复杂度O(1)
    public int maxSubArray(int[] nums) {

        int res = nums[0];
        for(int i = 1; i < nums.length;i++){

                if(nums[i-1] > 0) {

                    nums[i] = nums[i-1] + nums[i];
                }
                
                 res = Math.max(res,nums[i]);
        }
    	return res;
        
    }
```

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

```java
//首先相同的数异或为0
//所以对整个数组进行异或，可以得到x^y,其中x与y为只出现一次的数据，其他数据由于有相同的，所以异或为0；
//x与y不同，所以x^y中至少有一位为1，令m =1，让m不断左移，当m & (x^y)==0时，如：若x=15,y=3,则x=1111,y=0011,x^y=1100,可以得到m=100。
//将num分组，一组是第三位上为1，另一位是第三位上为0，通过与m相与就可以进行分组，这样x与y就分布在两个不同的数组中。

public int[] singleNumbers(int[] nums) {

        int x = 0,y = 0,n = 0, m = 1;
        for(int num : nums){

            n ^= num;
        }

        while((n & m) == 0){

            m <<= 1;
        }
         for(int num : nums){

            if((num & m) == 0) x ^= num;
            else{

                y ^= num;
            } 
        }

        return new int[]{x,y};



    }
```

#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

```java
/*  
            ab    ab    ab    ab
    状态机: 00 -> 01 -> 10 -> 00
    真值表:
    
    n   two  one  two' one'
    0    0    0   0    0
    0    0    1   0    1
    0    1    0   1    0
    1    0    0   0    1
    1    0    1   1    0
    1    1    0   0    0
计算one'  取one'为1的情况 one' = ~two&~one&n + ~two & one & ~n = ~two&(one^n)
因为计算完one’之后one就改变了，所以应该用新的one'替换旧的one,其他不变
n   two  one' two' 
0    0    0   0    
0    0    1   0    
0    1    0   1    
1    0    1   0    
1    0    0   1    
1    1    0   0       
two' = ~n & two & ~one + n & ~two & ~one = ~one(two^n)
时间复杂度 O(N)
空间复杂度 O(1)
*/
   
 public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num : nums){
            ones = ones ^ num & ~twos;
            twos = twos ^ num & ~ones;
       s }
        return ones;
    }


```

#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

```java
//先排序
//获取0的个数
//如果不是0就计算差值
//如果差值小于0就返回true;
//时间复杂度O(NlogN)空间复杂度O(1)
public boolean isStraight(int[] nums) {

         Arrays.sort(nums);
         int count = 0;
         int sum = 0;
    
         for(int i = 0; i < 4; i++){

             if(nums[i] == 0){

                 count ++;

             }else{
                 int temp = nums[i+1] - nums[i] -1;
                 if(temp < 0)  return false;
                 sum = sum + temp;         
             }

         }

         return count >= sum ? true :false;

    }
```

#### [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

```java
//直接左右指针
//和大于target right--
//和小于target left++
//和等于target  返回就行
//时间复杂度O(N)
//空间复杂度O(1)
public int[] twoSum(int[] nums, int target) {
        
        int left = 0;
        int right = nums.length - 1;
        while(left < right){

            if(nums[left] + nums[right] == target){

                break;
            }
            else if(nums[left] + nums[right] > target){

                right--;
            }else{

                left++;
            }
        }

        return new int[]{nums[left],nums[right]};


    }
```

#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

|      | a[0]=1 | a[1]=2 | a[2]=3 | a[3] =4 | a[4]=5 |
| ---- | ------ | ------ | ------ | ------- | ------ |
| b[0] | 1      | 2      | 3      | 4       | 5      |
| b[1] | 1      | 1      | 3      | 4       | 5      |
| b[2] | 1      | 2      | 1      | 4       | 5      |
| b[3] | 1      | 2      | 3      | 1       | 5      |
| b[4] | 1      | 2      | 3      | 4       | 1      |



```java
//先从上往下计算下三角的值，也就是b[i]=b[i-1]*a[i-1]
//之后从下往上计算上三角值，也就是temp=temp*a[i+1];  b[i]=temp*b[i]
//时间复杂度O(N)
//空间复杂度O(1)
public int[] constructArr(int[] a) {  
        int len = a.length;
        if(len == 0)  return a;
        int[] b = new int[len];
        b[0] = 1;
        int temp = 1;
        for(int i = 1; i < len; i++){

            b[i] = b[i-1] * a[i-1];
        }

        for(int j = len - 2; j >=0; j--){

            temp *= a[j + 1];
            b[j] = b[j] * temp;
        }

        return b;
    }
```

#### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```java
//使用hashset存储
//时间复杂度O(N)
//空间复杂度O(N)
public int findRepeatNumber(int[] nums) {
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i = 0; i < nums.length; i++){

            if(set.contains(nums[i])){

                return nums[i];
            }
            set.add(nums[i]);
        }
        return -1;

    }
```

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```java
//时间复杂度O(MN)
//空间复杂度O(MN)
	int count = 0;
    boolean [][]visited;
    public int movingCount(int m, int n, int k) {

          visited = new boolean[m][n];
          dfs(m,n,0,0,k);
          return count;

    }

    public void dfs(int m, int n, int i, int j,int k){

        int num1 = i >= 10 ? i/10 + i % 10 : i;
        int num2 = j >= 10 ? j/10 + j % 10 : j;
        if(i < 0 || i >= m || j < 0 || j >= n || num1 + num2 > k || visited[i][j]){

            return;
        }

        count ++;
        visited[i][j] = true;

        dfs(m,n,i-1,j,k);
        dfs(m,n,i+1,j,k);
        dfs(m,n,i,j-1,k);
        dfs(m,n,i,j+1,k);
  
    }
```

#### [容器盛水问题](https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f?tpId=196&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\容器盛水问题.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\容器盛水问题.png)

```java
//时间复杂度O(N)
//空间复杂度O(1)
public long maxWater (int[] arr) {
        // write code here
        
        long res=0L;
        int left=0;
        int right=arr.length-1;
        
        while(left<right){
            
           int min= arr[left]<arr[right] ? arr[left]:arr[right];//求两边的最小值
            
            while(left<right && arr[left]<=min){
                
                res+=min-arr[left];//用短的边减去中间波谷的值
                left++;
            }
            while(left<right && arr[right]<=min){
                
                res+=min-arr[right];
                right--;
            }
        }
        
        return res;
        
        
    }
```

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

```java
//时间复杂度O(N)
//空间复杂度O(1)
算法流程：
初始化： 左边界 i = 1 ，右边界 j = 2，元素和 s = 3 ，结果列表 res ；

循环： 当i≥j 时跳出；

当 s > target时： 向右移动左边界i=i+1 ，并更新元素和 s ；
当 s < target时： 向右移动右边界j=j+1 ，并更新元素和 s ；
当 s = target 时： 记录连续整数序列，并向右移动左边界 i=i+1 ；
返回值： 返回结果列表 res；

public int[][] findContinuousSequence(int target) {
        int i = 1, j = 2, s = 3;
        List<int[]> res = new ArrayList<>();
        while(i < j) {
            if(s == target) {
                int[] ans = new int[j - i + 1];
                for(int k = i; k <= j; k++)
                    ans[k - i] = k;
                res.add(ans);
            }
            if(s >= target) {
                s -= i;
                i++;
            } else {
                j++;
                s += j;
            }
        }
        return res.toArray(new int[0][]);
    }
```

#### [1.岛屿的数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

```java
//深度优先搜索:每搜到一个1就置为0
//时间复杂度：O(MN)
//空间复杂度：O(MN)递归的深度
public int numIslands(char[][] grid) {

        int nr=grid.length;
        int nc=grid[0].length;
        int res=0;
        for(int i=0;i<nr;i++){
            for(int j=0;j<nc;j++){

                if(grid[i][j]=='1'){

                    res++;
                    dfs(grid,i,j);
                }

            }
        }

        return res;
    }

    public void dfs (char[][]grid,int r,int c){

        int nr=grid.length;
        int nc=grid[0].length;

        if(r<0 || c<0|| r>=nr || c>=nc || grid[r][c]=='0'){

            return;
        }
        grid[r][c]='0';

        dfs(grid,r-1,c);
        dfs(grid,r+1,c);
        dfs(grid,r,c-1);
        dfs(grid,r,c+1);
    }
```

```java
//广度优先搜索
//思路是遍历数组，每遇到一个1就创建一个队列，把他周围的1全都加进队列
//时间复杂度：O(MN)
//空间复杂度：O(MN)队列的长度
public int numIslands(char[][] grid) {

        int nr=grid.length;
        int nc=grid[0].length;
        int res=0;
        for(int i=0;i<nr;i++){

            for(int j=0;j<nc;j++){

                if(grid[i][j]=='1'){
                  
                    res++;
                    grid[i][j]='0';
                    Queue<Integer>q=new LinkedList<Integer>();
                    q.add(i*nc+j);
                    while(!q.isEmpty()){
                        
                        int size=q.size();
                        for(int k=0;k<size;k++){

                            int idx=q.remove();
                            int r=idx/nc;
                            int c=idx%nc;
                            grid[r][c]='0';
                            if(r-1>=0 && grid[r-1][c]=='1'){

                                  q.add((r-1)*nc+c);
                                  grid[r-1][c]='0';

                            }
                            if(c-1>=0 && grid[r][c-1]=='1'){

                                 q.add(r*nc+c-1);
                                  grid[r][c-1]='0';

                            }if(r+1<nr && grid[r+1][c]=='1'){

                                 q.add((r+1)*nc+c);
                                  grid[r+1][c]='0';

                            }if(c+1<nc && grid[r][c+1]=='1'){

                                 q.add(r*nc+c+1);
                                  grid[r][c+1]='0';

                            }
                        }
                    }    
                                    
                }
            }
        }

        return res;
        
    }
```

#### [1. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。

给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

```java
//根据思路中的描述，按照数对第二个数的升序序列遍历所有数对，如果当前数对可以加入链，则加入。
//时间复杂度O(NlogN)  为排序的复杂度
//空间复杂度O(N)
public int findLongestChain(int[][] pairs) {

        Arrays.sort(pairs,(a,b)->a[1]-b[1]);

        int cur=Integer.MIN_VALUE;
        int res=0;

        for(int i=0;i<pairs.length;i++){

            if(cur<pairs[i][0]){

                cur=pairs[i][1];
                res++;
            }
        }

        return res;
    }
```

#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

参考代码：https://leetcode-cn.com/problems/wiggle-subsequence/solution/376-bai-dong-xu-lie-tan-xin-jing-dian-ti-vyxt/

![](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\摆动序列.png)

```java
public int wiggleMaxLength(int[] nums) {
        if(nums.length==0 || nums.length==1) return nums.length;

        int res=1;
        int up=3;  //up=1,表示上升，up=2，表示下降，up=3，表示相等
        for(int i=1;i<nums.length;i++){

            if(nums[i]>nums[i-1] && up!=1){//如果该元素为上升元素，并且之前不是上升的，则说明是波动的

                res++;
                up=1;//说明处于上升状态
            }else if(nums[i]<nums[i-1] && up!=2){//如果该元素为下降元素，并且之前不是下降的，则说明是波动的

                res++;
                up=2;//说明处于下降状态
            }
        }
        return res;

    }
```

#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\求和.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\求和.png)

```java
//设无进位和为n(i),进位为c(i+1)
//n(i) = a ^b    c(i+1) = a& b
//当c!=0时，和为n+c 继续上次循环，然后直到c=0;\
//时间复杂度O(1)： 最差情况下（例如 a =0x7fffffff,b=1 时），需循环 32 次，使用O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。
//空间复杂度O(1)

public int add(int a, int b) {


        while(b!=0){//当进位不为0

            int c = (a & b) << 1;//获取进位
            a ^= b;//获取无进位和
            b = c;//继续下次相加
        }
        return a;
    }
```

#### [1.用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

```java
//插入和删除时间复杂度为O(1)，对于删除元素，虽然看起来时O(N)的时间复杂度，但是仔细考虑一下每个元素只会至多被插入或者弹出stack2一次，因此均摊下来每个元素的时间复杂度仍为O(1)
//空间复杂度O(N)
Stack<Integer> stack1 = new Stack<Integer>();
Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        
        stack1.add(node);//栈1直接加进去
        
    }
    
    public int pop() {
        
        
        if(stack1.isEmpty()&&stack2.isEmpty()) return -1;//当两个栈都为空时，没有办法弹出
        if(stack2.isEmpty()){//当栈2为空时，把栈1直接倒到栈2中
            
            while(!stack1.isEmpty()){

                stack2.add(stack1.pop());

            }
        } 
        return stack2.pop();
    
    }
```

#### [2.括号序列](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

```java
//时间复杂度O(N)
//空间复杂度O(N)
public boolean isValid (String s) {
        // write code here
        
        Stack<Character> st=new Stack();
       
        for(int i=0;i<s.length();i++){
            
           char temp=s.charAt(i);
         
          if(temp=='[') 
                st.push(']');
            else if(temp=='{') 
                st.push('}');
            else if(temp=='(')
                st.push(')');
            else if(st.isEmpty() ||temp!= st.pop()){
                
               return false;
            }
        }
        
      return st.isEmpty();
       
        
    }
```

#### [3. 设计getMin功能的栈](https://leetcode-cn.com/problems/min-stack/)

实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。1: push   2: pop  3:getMin

输入：`[[1,3],[1,2],[1,1],[3],[2],[3]]  `   

输出; `[1,2]`

```java
//时间复杂度：O(1)
//空间复杂度O(N)
public Stack<Integer> s;
    public  Stack<Integer> min_s;
    public int[] getMinStack (int[][] op) {
        // write code here
        s=new Stack<Integer>();
        min_s=new Stack<Integer>();
       ArrayList<Integer> temp=new ArrayList<Integer>();
        
       for(int i=0;i<op.length;i++){
           
           if(op[i][0]==1){
               
               push(op[i][1]);
           }else if(op[i][0]==2){
               pop();
           }else{
               
               temp.add(getMin());
           }
       }
       int []res=new int[temp.size()]; 
        for(int i =0;i<temp.size();i++){
            
            res[i]=temp.get(i);
        }
        
        return res;
        
    }
    
    public void push(int i){
        
        s.push(i);
        if(min_s.isEmpty() ||min_s.peek()>=i){
            min_s.push(i);
        }      
    }
    public void pop(){
        
        int val=s.pop();
        if(val== min_s.peek()){//如果最小栈中也有这个元素，也需要弹出
            min_s.pop();           
        }
 
        
    }
    
    public int getMin(){
        
        return min_s.peek();
        

    }
```

#### [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

```java
//时间复杂度O(1)
//空间复杂度O(N)
class MaxQueue {

    public Queue<Integer> q;//定义一个队列用于存储数据
    public Deque<Integer> q_max;//定义一个双端队列，这个队列可以获取队头和队尾

    public MaxQueue() {

        q = new LinkedList<Integer>();//
        q_max = new LinkedList<Integer>();

    }
    
    public int max_value() {//最大值

        if(!q_max.isEmpty()){//当双向队列不为空，就返回队头元素

            return q_max.peekFirst();
        }
        return -1;//为空就返回-1

    }
    
    public void push_back(int value) {

        q.add(value);//队列直接加入元素
        while(!q_max.isEmpty() && q_max.peekLast() < value){//当队尾元素小于加入的元素，就弹出，保证这个队列是单调递减的队列

             q_max.pollLast();
        }
         q_max.offerLast(value);//不然就直接将元素加入队尾
        

    }
    
    public int pop_front() {
 
      int value = -1;
      if(!q.isEmpty()){//

           value = q.poll();//先把队列中元素弹出
            if(q_max.peekFirst() == value)   q_max.pollFirst();  //如果双端队列中队首元素与弹出元素相同，那么也弹出  
      }
      return value;

    }
}
```

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

```java
/*算法流程：
初始化： 双端队列 deque ，结果列表 res ，数组长度 n ；
滑动窗口： 左边界范围 i∈[1−k,n−k] ，右边界范围 j∈[0,n−1] ；
若 i>0 且 队首元素 deque[0]=被删除元素 nums[i−1] ：则队首元素出队；
删除 deque 内所有 <nums[j] 的元素，以保持 deque 递减；
将 nums[j] 添加至 deque 尾部；
若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 res；
时间复杂度O(N)
空间复杂度O(K)//k表示窗口大小
*/
public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0 || k == 0)  return new int[0];

        Deque <Integer> q = new LinkedList<>();//创建一个双端队列
        int []res = new int[nums.length - k + 1];

        for(int i = 0; i < k; i++){//把前k个元素加入队列

            while(!q.isEmpty() && q.peekLast() < nums[i]){//保证队列单调递减，要把小于num[i]的元素弹出

                    q.pollLast();
            }
            q.addLast(nums[i]);//把Num[i]加入
        }

        res[0] = q.peekFirst();//第一个结果为队列的最大值

        for(int i = k; i < nums.length; i++){

            if(q.peekFirst() == nums[i-k]){//如果最大值等于我们删除的元素，需要移除队列

                q.pollFirst();
            }

            while(!q.isEmpty() && q.peekLast() < nums[i]){//保证队列单调递减

                q.pollLast();
            }
            q.addLast(nums[i]);
            res[i - k + 1] = q.peekFirst();


        }

        return res;

    }
```

#### [1.找到字符串的最长无重复字符子串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/)

给定一个数组arr，返回arr的最长无重复子串的长度(无重复指的是所有数字都不相同)。

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\字符串的最长无重复字符子串.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\字符串的最长无重复字符子串.png)

```java
//时间复杂度：O(N)  其中N为字符串长度，动态规划需要遍历计算dp列表。
//空间复杂度O(1) 数字的范围为0-9，最多使用O(10)=O(1)大小的额外空间。
public int maxLength (int[] arr) {
        // write code here
        int temp=0;int res=0;
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int j=0;j<arr.length;j++){
            
            int i=map.getOrDefault(arr[j],-1);
            map.put(arr[j],j);
            temp=temp<j-i?temp+1:j-i;
            res=Math.max(res,temp);
        }
        
        return res;
    }
```

![D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\字符串1.png](D:\sjtu\AIR\SYY\JOB\Note\doc\DataStructures\images\字符串1.png)

```java
public int maxLength (int[] arr) {
        // write code here
        int i=-1;int res=0;
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int j=0;j<arr.length;j++){
            
           if(map.containsKey(arr[j]))
                i=Math.max(i,map.get(arr[j]));//确保i，j之间没有重复
            map.put(arr[j],j);
            res=Math.max(res,j-i);
        }
        
        return res;
    }
```

#### [2.大数加法](https://leetcode-cn.com/problems/add-strings/)

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。

```java
 //时间复杂度O(max{M,N})
//空间复杂度O(n)
public String solve (String s, String t) {
        // write code here
        StringBuilder sb=new StringBuilder();
        
        int i=s.length()-1;
        int j=t.length()-1;
        int carry=0;
        
        while(i>=0 || j>=0 || carry!=0){
            
            int sn = i < 0 ? 0 : s.charAt(i--)-'0';
            int tn = j < 0 ? 0 : t.charAt(j--)-'0';
            
            int sum=sn+tn+carry;
            
            if(sum>=10){
                
                sum=sum%10;
                carry=1;
            }else{
                carry=0;
            }
            sb.append(sum);
            
        }
        return sb.reverse().toString();
    }
```

#### [3.最长公共子串](https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=196&tqId=37132&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)

给定两个字符串str1和str2,输出两个字符串的最长公共子串

题目保证str1和str2的最长公共子串存在且唯一。

```java
//思路：dp[i][j]表示以i-1为结尾的最长公共子串
//使用动态规划
//时间复杂度O(MN) 空间复杂度O(MN)
public String LCS (String str1, String str2) {
        // write code here
        int m=str1.length();
        int n=str2.length();
        int max=0; int end=0;
        int [][]dp=new int[m+1][n+1];
        for(int i=1;i<=m;i++){
            char c1=str1.charAt(i-1);
            for(int j=1;j<=n;j++){
                char c2=str2.charAt(j-1);
                if(c1==c2) dp[i][j]=dp[i-1][j-1]+1;//如果相等的话，就前面的加1
                else{
                    
                   dp[i][j]=0;//不相等的话就说明没有公共子串
                }
                
                if(dp[i][j]>max){//找最长的
                    
                    max=dp[i][j];
                    end=i-1;
                }
              
            }
        }
        
        return str1.substring(end-max+1,end+1);
        
       
    }
```

#### [4. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）

```java
//时间复杂度O(N) 空间复杂度O(N)
public String solve (String str) {
        // write code here
        
        StringBuilder res=new StringBuilder();
        for(int i=str.length()-1;i>=0;i--){
            
            res.append(str.charAt(i));
        }
        
        return res.toString();
            
            
    }
```

#### [5.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。

给定字符串**A**以及它的长度**n**，请返回最长回文子串的长度。

输入："abc1234321ab",12

输出：7

使用马拉车算法(https://segmentfault.com/a/1190000008484167)

```java
public int getLongestPalindrome(String A, int n) {
        // write code here
        
        return  Manacher(A,n);
    }
    
    public int Manacher(String A,int n){
        int len= 2*n+3;
        char[] newchar=new char[len];
        newchar[0]='$';
        newchar[1]='#';
        int j=2;
        for(int i=0;i<A.length();i++){
            
            newchar[j++]=A.charAt(i);
            newchar[j++]='#';
            
        }
        newchar[j]='^';//往字符串中加上#  如“abcbc”变为“$#a#b#c#b#c#^”
       
        int []dp=new int[len];//dp[i]表示位于i的最大回文半径 如#a#b#a#中b的回文半径为4，真实的回文串为4-1=3
        int max=0;
        int id=0;
        int maxlen=0;
        for(int i=1;i<len-1;i++){
            
            
            if(i<max){
                
                dp[i]=Math.min(max-i,dp[2*id-i]);//初始化回文半径
            }else{
                
                dp[i]=1;
            }
            
            while(newchar[i+dp[i]]== newchar[i-dp[i]]){
                
                dp[i]=dp[i]+1;
            }
            
            if(i+dp[i]>max){//更新max
                
                max=i+dp[i];
                id=i;
            }
            
            maxlen=Math.max(maxlen,dp[i]-1);
            
        }
            
            return maxlen;
        
        
        
    }
```

#### [6.判断回文字符串](https://leetcode-cn.com/problems/valid-palindrome/submissions/)

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```java
//使用双指针
//时间复杂度O(N)
//空间复杂度O(1)
public boolean isPalindrome(String s) {

        int i=0;
        int j=s.length()-1;
        
       
        while(i<=j){

            while(i<=j && !Character.isLetterOrDigit(s.charAt(i))){

                i++;
            }
            while(i<=j && !Character.isLetterOrDigit(s.charAt(j))){

                j--;
            }
            if(Character.isLetterOrDigit(s.charAt(j)) && Character.isLetterOrDigit(s.charAt(i))){

                if(Character.toLowerCase(s.charAt(i))!=Character.toLowerCase(s.charAt(j))) return false;
                i++;
                j--;



            }
        
        
        
        }

        return true;
    }
}
```

#### [6.字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

- 回溯法

```java
//时间复杂度：O(N!N) N为字符串长度，时间复杂度和字符串排列的方案成线性关系，方案数为N!,字符串拼接操作join()使用O(N)
//空间复杂度:O(N^2)排列的递归深度为 NN ，系统累计使用栈空间大小为 O(N)O(N) ；递归中辅助 Set 累计存储的字符数量最多为 N + (N-1) + ... + 2 + 1 = (N+1)N/2，即占用 O(N^2) 的额外空间。
List<String> res = new LinkedList<>();
    char[] c;
    public String[] permutation(String s) {
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }
    void dfs(int x) {
        if(x == c.length - 1) {
            res.add(String.valueOf(c));      // 添加排列方案
            return;
        }
        HashSet<Character> set = new HashSet<>();
        for(int i = x; i < c.length; i++) {
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x);                      // 交换，将 c[i] 固定在第 x 位
            dfs(x + 1);                      // 开启固定第 x + 1 位字符
            swap(i, x);                      // 恢复交换
        }
    }
    void swap(int a, int b) {
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    }
```

- 字典序法 https://blog.nowcoder.net/n/dfd91d416f064002b8b05e89953d5b92

  简单的讲：
  1、从右向左找到第一个正序对（array[i] < array[i+1]，因为没有等号，所以可以完美去掉重复的排列）
  2、从i开始向右搜索，找到比array[i]大的字符中最小的那个，记为array[j]
  3、交换array[i]和array[j]
  4、将i后面的字符反转
  这就得到了字典序的下一个排列。

  ```java
   //时间复杂度O(N!N);每生成一个当前排列的下一个排列，复杂度为O(N);
  
  public String[] permutation(String s) {
  
         List<String> res = new LinkedList<>();
         if(s.length()==0) return  res.toArray(new String[res.size()]);;
         char[] c = s.toCharArray();
         Arrays.sort(c);
         String str=new String(c);
         res.add(str);
         while(true){
  
             str=nextString(str);
             if(!str.equals("Finish")){
                    
                    res.add(str);
                    
             }else{
                 break;
             }
         }
         return  res.toArray(new String[res.size()]);
  
      }
      public String nextString (String s) {
          char []array=s.toCharArray();
          int i=s.length()-2;
          for(;i>=0 && array[i]>array[i+1];i--);/
              
          if(i==-1) return "Finish";
          
          int j=s.length()-1;
          for(;array[j]<array[i];j--);//因为i后面的是按照降序排的
  
          char temp=array[i];
          array[i]=array[j];
          array[j]=temp;
  
          int a=i+1;
          int b=s.length()-1;
          while(a<=b){
              temp=array[a];
              array[a]=array[b];
              array[b]=temp;
              a++;
              b--;
          }
  
          return new String(array);
          
      }
  
  ```

  #### [7.表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

分为两步: 由中缀表达式转为后缀表达式：从左到右遍历中缀表达式的每个数字和符号，如果是数字，就输出，即成为后缀表达式的一部分，如果是符号，则判断与栈顶元素的优先级（右括号>乘除>加减>左括号），是右括号或者优先级小于等于栈顶符号，则栈顶元素依次出栈并输出，并将该符号出栈，一直到最终输出后缀表达式为止。

由后缀表达求值：遍历字符串，如果是数字就入栈，如果是符号，就将栈顶两个元素拿出计算然后入栈。

```java
//中缀表达式转后缀表达式
//逆波兰表达式求值
//tokens 为后缀表达式
public int evalRPN(String[] tokens) {

       Stack<Integer> st=new Stack<Integer>();
       int num1=0;
       int num2=0;
       int num=0;

       for(String s:tokens){

           switch(s){

               case "+":

               num1=st.pop();
               num2=st.pop();
               num=num1+num2;
               st.push(num);
               break;
               case "-":
                num1=st.pop();
                num2=st.pop();
                num=num2-num1;
                st.push(num);

               break;
               
               case "*":
                num1=st.pop();
                num2=st.pop();
                num=num2*num1;
                st.push(num);
               break;
               case "/":
                num1=st.pop();
                num2=st.pop();
                num=num2/num1;
                st.push(num);

               break;
               default:
                 st.push(Integer.parseInt(s));

            
               
           }
       }
       return st.pop();


    }
```

#### [8.计算器](https://leetcode-cn.com/problems/basic-calculator-ii/)

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

```java
//时间复杂度O(N) 空间复杂度O(N)
 //由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。
//基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。
//具体来说，遍历字符串 s，并用变量preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 preSign 来决定计算方式：
//加号：将数字压入栈；
//减号：将数字的相反数压入栈；
//乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。
//代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 \textit{preSign}preSign 为当前遍历的字符。

//遍历完字符串 s 后，将栈中元素累加，即为该字符串表达式的值。


public int calculate(String s) {

        Stack<Integer> st=new Stack<>();
        int num=0;
        char presign ='+';
    
        for(int i=0;i<s.length();i++){

            if(Character.isDigit(s.charAt(i))){

                num=num*10+(s.charAt(i)-'0');
            }

            if((!Character.isDigit(s.charAt(i)) && s.charAt(i)!=' ')|| i==s.length()-1 ){

                switch(presign){

                    case '+':
                       st.push(num);
                    break;
                    case '-':
                     st.push(-num);
                    break;
                    case '*':
                    st.push(st.pop()*num);
                    break;
                    case '/':
                     st.push(st.pop()/num);
                    break;
                    default:
                }

                presign=s.charAt(i);
                num=0;
            }
        }
        while(!st.isEmpty()){

            num+=st.pop();
        }

        return num;



    }
```

#### [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

```java
//遍历字符串，使用一个map存放字符出现的个数，最后遍历map找到第一个个数为1的字符
//时间复杂度O(N)
//空间复杂度O(∣Σ∣)，其中 Σ 是字符集，在本题中 ss 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。

public char firstUniqChar(String s) {

        HashMap<Character,Integer> map = new HashMap<Character,Integer>();
        for(int i = 0;i < s.length();i++){
           
            char ch = s.charAt(i);
            map.put(ch,map.getOrDefault(ch,0) + 1);
            
        }

        for(int i = 0; i < s.length();i++){

            if(map.get(s.charAt(i)) == 1){

                return s.charAt(i);
            }
        }

        return ' ';

    }
```

#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

```java
//时间复杂度O(N)
//空间复杂度O(N)
public String reverseLeftWords(String s, int n) {

      StringBuilder sb = new StringBuilder();
      for(int i = n; i < s.length();i++){

          sb.append(s.charAt(i));
      }

      for(int i = 0; i < n;i++){

          sb.append(s.charAt(i));
      }

      return new String(sb);


    }
```

#### [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

 

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。

```java
//先计算边界： boundary = Integer.MAX_VALUE/10;
//先把前面的空格都给遍历了
//再判断有没有正负号
//之后遍历，如果是数字,先判断有没有越界，不然就加进去
//如果不是数字，直接返回。
//时间复杂度O(N)
//空间复杂度O(1)
public int strToInt(String str) {

        if(str == null || str.length() == 0) return 0;
        int sign = 1;
        int i = 0;
        int num = 0;
        int boundary = Integer.MAX_VALUE/10;

        while(i < str.length() && str.charAt(i) == ' '){

                i++;
                if(i == str.length()) return 0;
        }

        if(str.charAt(i) == '-'){

              sign = -1;
              i++;

        }else if(str.charAt(i) == '+'){

             i++;
        }
        
        for(; i < str.length();i++){
            
            char ch = str.charAt(i);

            if(Character.isDigit(ch)){

                if(num > boundary || num == boundary && ch > '7'){

                    return sign ==1 ? Integer.MAX_VALUE:Integer.MIN_VALUE;
                }
                num = num * 10 + ch - '0';

            }else{

                break;
            }
                
        }
        
        return sign * num;



    }
```

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

```java
//先去掉s的前后空格
//再从后往前遍历，遇到空格就把i~j的字符串加入sb中
//时间复杂度O(N)
//空间复杂度O(N)
public String reverseWords(String s) {

       s.trim();
       StringBuilder sb = new StringBuilder();
       int j = s.length()-1;
       int i = j;
       while(i >= 0){

           while(i >= 0 && s.charAt(i) != ' ') i--;
           sb.append(s.substring(i+1,j+1)+" ");
           while(i >= 0 && s.charAt(i) ==' ') i--;
           j = i;
        
       }

       return new String(sb).trim();
    }
```

